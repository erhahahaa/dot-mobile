// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'question_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$QuestionEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllQuestionParams params) getQuestions,
    required TResult Function(String query) filterQuestions,
    required TResult Function(List<CreateQuestionParams> params) createBatch,
    required TResult Function(List<UpdateQuestionParams> params) updateBatch,
    required TResult Function(DeleteQuestionParams params) delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllQuestionParams params)? getQuestions,
    TResult? Function(String query)? filterQuestions,
    TResult? Function(List<CreateQuestionParams> params)? createBatch,
    TResult? Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult? Function(DeleteQuestionParams params)? delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllQuestionParams params)? getQuestions,
    TResult Function(String query)? filterQuestions,
    TResult Function(List<CreateQuestionParams> params)? createBatch,
    TResult Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult Function(DeleteQuestionParams params)? delete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionEventClear value) clear,
    required TResult Function(QuestionEventGetQuestions value) getQuestions,
    required TResult Function(QuestionEventFilterQuestions value)
        filterQuestions,
    required TResult Function(QuestionEventCreateBatch value) createBatch,
    required TResult Function(QuestionEventUpdateBatch value) updateBatch,
    required TResult Function(QuestionEventDelete value) delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionEventClear value)? clear,
    TResult? Function(QuestionEventGetQuestions value)? getQuestions,
    TResult? Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult? Function(QuestionEventCreateBatch value)? createBatch,
    TResult? Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult? Function(QuestionEventDelete value)? delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionEventClear value)? clear,
    TResult Function(QuestionEventGetQuestions value)? getQuestions,
    TResult Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult Function(QuestionEventCreateBatch value)? createBatch,
    TResult Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult Function(QuestionEventDelete value)? delete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionEventCopyWith<$Res> {
  factory $QuestionEventCopyWith(
          QuestionEvent value, $Res Function(QuestionEvent) then) =
      _$QuestionEventCopyWithImpl<$Res, QuestionEvent>;
}

/// @nodoc
class _$QuestionEventCopyWithImpl<$Res, $Val extends QuestionEvent>
    implements $QuestionEventCopyWith<$Res> {
  _$QuestionEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$QuestionEventClearImplCopyWith<$Res> {
  factory _$$QuestionEventClearImplCopyWith(_$QuestionEventClearImpl value,
          $Res Function(_$QuestionEventClearImpl) then) =
      __$$QuestionEventClearImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QuestionEventClearImplCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res, _$QuestionEventClearImpl>
    implements _$$QuestionEventClearImplCopyWith<$Res> {
  __$$QuestionEventClearImplCopyWithImpl(_$QuestionEventClearImpl _value,
      $Res Function(_$QuestionEventClearImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$QuestionEventClearImpl implements QuestionEventClear {
  const _$QuestionEventClearImpl();

  @override
  String toString() {
    return 'QuestionEvent.clear()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$QuestionEventClearImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllQuestionParams params) getQuestions,
    required TResult Function(String query) filterQuestions,
    required TResult Function(List<CreateQuestionParams> params) createBatch,
    required TResult Function(List<UpdateQuestionParams> params) updateBatch,
    required TResult Function(DeleteQuestionParams params) delete,
  }) {
    return clear();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllQuestionParams params)? getQuestions,
    TResult? Function(String query)? filterQuestions,
    TResult? Function(List<CreateQuestionParams> params)? createBatch,
    TResult? Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult? Function(DeleteQuestionParams params)? delete,
  }) {
    return clear?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllQuestionParams params)? getQuestions,
    TResult Function(String query)? filterQuestions,
    TResult Function(List<CreateQuestionParams> params)? createBatch,
    TResult Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult Function(DeleteQuestionParams params)? delete,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionEventClear value) clear,
    required TResult Function(QuestionEventGetQuestions value) getQuestions,
    required TResult Function(QuestionEventFilterQuestions value)
        filterQuestions,
    required TResult Function(QuestionEventCreateBatch value) createBatch,
    required TResult Function(QuestionEventUpdateBatch value) updateBatch,
    required TResult Function(QuestionEventDelete value) delete,
  }) {
    return clear(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionEventClear value)? clear,
    TResult? Function(QuestionEventGetQuestions value)? getQuestions,
    TResult? Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult? Function(QuestionEventCreateBatch value)? createBatch,
    TResult? Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult? Function(QuestionEventDelete value)? delete,
  }) {
    return clear?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionEventClear value)? clear,
    TResult Function(QuestionEventGetQuestions value)? getQuestions,
    TResult Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult Function(QuestionEventCreateBatch value)? createBatch,
    TResult Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult Function(QuestionEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear(this);
    }
    return orElse();
  }
}

abstract class QuestionEventClear implements QuestionEvent {
  const factory QuestionEventClear() = _$QuestionEventClearImpl;
}

/// @nodoc
abstract class _$$QuestionEventGetQuestionsImplCopyWith<$Res> {
  factory _$$QuestionEventGetQuestionsImplCopyWith(
          _$QuestionEventGetQuestionsImpl value,
          $Res Function(_$QuestionEventGetQuestionsImpl) then) =
      __$$QuestionEventGetQuestionsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({GetAllQuestionParams params});

  $GetAllQuestionParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$QuestionEventGetQuestionsImplCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res, _$QuestionEventGetQuestionsImpl>
    implements _$$QuestionEventGetQuestionsImplCopyWith<$Res> {
  __$$QuestionEventGetQuestionsImplCopyWithImpl(
      _$QuestionEventGetQuestionsImpl _value,
      $Res Function(_$QuestionEventGetQuestionsImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_$QuestionEventGetQuestionsImpl(
      null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as GetAllQuestionParams,
    ));
  }

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GetAllQuestionParamsCopyWith<$Res> get params {
    return $GetAllQuestionParamsCopyWith<$Res>(_value.params, (value) {
      return _then(_value.copyWith(params: value));
    });
  }
}

/// @nodoc

class _$QuestionEventGetQuestionsImpl implements QuestionEventGetQuestions {
  const _$QuestionEventGetQuestionsImpl(this.params);

  @override
  final GetAllQuestionParams params;

  @override
  String toString() {
    return 'QuestionEvent.getQuestions(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionEventGetQuestionsImpl &&
            (identical(other.params, params) || other.params == params));
  }

  @override
  int get hashCode => Object.hash(runtimeType, params);

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionEventGetQuestionsImplCopyWith<_$QuestionEventGetQuestionsImpl>
      get copyWith => __$$QuestionEventGetQuestionsImplCopyWithImpl<
          _$QuestionEventGetQuestionsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllQuestionParams params) getQuestions,
    required TResult Function(String query) filterQuestions,
    required TResult Function(List<CreateQuestionParams> params) createBatch,
    required TResult Function(List<UpdateQuestionParams> params) updateBatch,
    required TResult Function(DeleteQuestionParams params) delete,
  }) {
    return getQuestions(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllQuestionParams params)? getQuestions,
    TResult? Function(String query)? filterQuestions,
    TResult? Function(List<CreateQuestionParams> params)? createBatch,
    TResult? Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult? Function(DeleteQuestionParams params)? delete,
  }) {
    return getQuestions?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllQuestionParams params)? getQuestions,
    TResult Function(String query)? filterQuestions,
    TResult Function(List<CreateQuestionParams> params)? createBatch,
    TResult Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult Function(DeleteQuestionParams params)? delete,
    required TResult orElse(),
  }) {
    if (getQuestions != null) {
      return getQuestions(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionEventClear value) clear,
    required TResult Function(QuestionEventGetQuestions value) getQuestions,
    required TResult Function(QuestionEventFilterQuestions value)
        filterQuestions,
    required TResult Function(QuestionEventCreateBatch value) createBatch,
    required TResult Function(QuestionEventUpdateBatch value) updateBatch,
    required TResult Function(QuestionEventDelete value) delete,
  }) {
    return getQuestions(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionEventClear value)? clear,
    TResult? Function(QuestionEventGetQuestions value)? getQuestions,
    TResult? Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult? Function(QuestionEventCreateBatch value)? createBatch,
    TResult? Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult? Function(QuestionEventDelete value)? delete,
  }) {
    return getQuestions?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionEventClear value)? clear,
    TResult Function(QuestionEventGetQuestions value)? getQuestions,
    TResult Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult Function(QuestionEventCreateBatch value)? createBatch,
    TResult Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult Function(QuestionEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (getQuestions != null) {
      return getQuestions(this);
    }
    return orElse();
  }
}

abstract class QuestionEventGetQuestions implements QuestionEvent {
  const factory QuestionEventGetQuestions(final GetAllQuestionParams params) =
      _$QuestionEventGetQuestionsImpl;

  GetAllQuestionParams get params;

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionEventGetQuestionsImplCopyWith<_$QuestionEventGetQuestionsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QuestionEventFilterQuestionsImplCopyWith<$Res> {
  factory _$$QuestionEventFilterQuestionsImplCopyWith(
          _$QuestionEventFilterQuestionsImpl value,
          $Res Function(_$QuestionEventFilterQuestionsImpl) then) =
      __$$QuestionEventFilterQuestionsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String query});
}

/// @nodoc
class __$$QuestionEventFilterQuestionsImplCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res,
        _$QuestionEventFilterQuestionsImpl>
    implements _$$QuestionEventFilterQuestionsImplCopyWith<$Res> {
  __$$QuestionEventFilterQuestionsImplCopyWithImpl(
      _$QuestionEventFilterQuestionsImpl _value,
      $Res Function(_$QuestionEventFilterQuestionsImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? query = null,
  }) {
    return _then(_$QuestionEventFilterQuestionsImpl(
      null == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$QuestionEventFilterQuestionsImpl
    implements QuestionEventFilterQuestions {
  const _$QuestionEventFilterQuestionsImpl(this.query);

  @override
  final String query;

  @override
  String toString() {
    return 'QuestionEvent.filterQuestions(query: $query)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionEventFilterQuestionsImpl &&
            (identical(other.query, query) || other.query == query));
  }

  @override
  int get hashCode => Object.hash(runtimeType, query);

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionEventFilterQuestionsImplCopyWith<
          _$QuestionEventFilterQuestionsImpl>
      get copyWith => __$$QuestionEventFilterQuestionsImplCopyWithImpl<
          _$QuestionEventFilterQuestionsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllQuestionParams params) getQuestions,
    required TResult Function(String query) filterQuestions,
    required TResult Function(List<CreateQuestionParams> params) createBatch,
    required TResult Function(List<UpdateQuestionParams> params) updateBatch,
    required TResult Function(DeleteQuestionParams params) delete,
  }) {
    return filterQuestions(query);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllQuestionParams params)? getQuestions,
    TResult? Function(String query)? filterQuestions,
    TResult? Function(List<CreateQuestionParams> params)? createBatch,
    TResult? Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult? Function(DeleteQuestionParams params)? delete,
  }) {
    return filterQuestions?.call(query);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllQuestionParams params)? getQuestions,
    TResult Function(String query)? filterQuestions,
    TResult Function(List<CreateQuestionParams> params)? createBatch,
    TResult Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult Function(DeleteQuestionParams params)? delete,
    required TResult orElse(),
  }) {
    if (filterQuestions != null) {
      return filterQuestions(query);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionEventClear value) clear,
    required TResult Function(QuestionEventGetQuestions value) getQuestions,
    required TResult Function(QuestionEventFilterQuestions value)
        filterQuestions,
    required TResult Function(QuestionEventCreateBatch value) createBatch,
    required TResult Function(QuestionEventUpdateBatch value) updateBatch,
    required TResult Function(QuestionEventDelete value) delete,
  }) {
    return filterQuestions(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionEventClear value)? clear,
    TResult? Function(QuestionEventGetQuestions value)? getQuestions,
    TResult? Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult? Function(QuestionEventCreateBatch value)? createBatch,
    TResult? Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult? Function(QuestionEventDelete value)? delete,
  }) {
    return filterQuestions?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionEventClear value)? clear,
    TResult Function(QuestionEventGetQuestions value)? getQuestions,
    TResult Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult Function(QuestionEventCreateBatch value)? createBatch,
    TResult Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult Function(QuestionEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (filterQuestions != null) {
      return filterQuestions(this);
    }
    return orElse();
  }
}

abstract class QuestionEventFilterQuestions implements QuestionEvent {
  const factory QuestionEventFilterQuestions(final String query) =
      _$QuestionEventFilterQuestionsImpl;

  String get query;

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionEventFilterQuestionsImplCopyWith<
          _$QuestionEventFilterQuestionsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QuestionEventCreateBatchImplCopyWith<$Res> {
  factory _$$QuestionEventCreateBatchImplCopyWith(
          _$QuestionEventCreateBatchImpl value,
          $Res Function(_$QuestionEventCreateBatchImpl) then) =
      __$$QuestionEventCreateBatchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<CreateQuestionParams> params});
}

/// @nodoc
class __$$QuestionEventCreateBatchImplCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res, _$QuestionEventCreateBatchImpl>
    implements _$$QuestionEventCreateBatchImplCopyWith<$Res> {
  __$$QuestionEventCreateBatchImplCopyWithImpl(
      _$QuestionEventCreateBatchImpl _value,
      $Res Function(_$QuestionEventCreateBatchImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_$QuestionEventCreateBatchImpl(
      null == params
          ? _value._params
          : params // ignore: cast_nullable_to_non_nullable
              as List<CreateQuestionParams>,
    ));
  }
}

/// @nodoc

class _$QuestionEventCreateBatchImpl implements QuestionEventCreateBatch {
  const _$QuestionEventCreateBatchImpl(final List<CreateQuestionParams> params)
      : _params = params;

  final List<CreateQuestionParams> _params;
  @override
  List<CreateQuestionParams> get params {
    if (_params is EqualUnmodifiableListView) return _params;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_params);
  }

  @override
  String toString() {
    return 'QuestionEvent.createBatch(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionEventCreateBatchImpl &&
            const DeepCollectionEquality().equals(other._params, _params));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_params));

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionEventCreateBatchImplCopyWith<_$QuestionEventCreateBatchImpl>
      get copyWith => __$$QuestionEventCreateBatchImplCopyWithImpl<
          _$QuestionEventCreateBatchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllQuestionParams params) getQuestions,
    required TResult Function(String query) filterQuestions,
    required TResult Function(List<CreateQuestionParams> params) createBatch,
    required TResult Function(List<UpdateQuestionParams> params) updateBatch,
    required TResult Function(DeleteQuestionParams params) delete,
  }) {
    return createBatch(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllQuestionParams params)? getQuestions,
    TResult? Function(String query)? filterQuestions,
    TResult? Function(List<CreateQuestionParams> params)? createBatch,
    TResult? Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult? Function(DeleteQuestionParams params)? delete,
  }) {
    return createBatch?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllQuestionParams params)? getQuestions,
    TResult Function(String query)? filterQuestions,
    TResult Function(List<CreateQuestionParams> params)? createBatch,
    TResult Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult Function(DeleteQuestionParams params)? delete,
    required TResult orElse(),
  }) {
    if (createBatch != null) {
      return createBatch(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionEventClear value) clear,
    required TResult Function(QuestionEventGetQuestions value) getQuestions,
    required TResult Function(QuestionEventFilterQuestions value)
        filterQuestions,
    required TResult Function(QuestionEventCreateBatch value) createBatch,
    required TResult Function(QuestionEventUpdateBatch value) updateBatch,
    required TResult Function(QuestionEventDelete value) delete,
  }) {
    return createBatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionEventClear value)? clear,
    TResult? Function(QuestionEventGetQuestions value)? getQuestions,
    TResult? Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult? Function(QuestionEventCreateBatch value)? createBatch,
    TResult? Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult? Function(QuestionEventDelete value)? delete,
  }) {
    return createBatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionEventClear value)? clear,
    TResult Function(QuestionEventGetQuestions value)? getQuestions,
    TResult Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult Function(QuestionEventCreateBatch value)? createBatch,
    TResult Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult Function(QuestionEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (createBatch != null) {
      return createBatch(this);
    }
    return orElse();
  }
}

abstract class QuestionEventCreateBatch implements QuestionEvent {
  const factory QuestionEventCreateBatch(
      final List<CreateQuestionParams> params) = _$QuestionEventCreateBatchImpl;

  List<CreateQuestionParams> get params;

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionEventCreateBatchImplCopyWith<_$QuestionEventCreateBatchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QuestionEventUpdateBatchImplCopyWith<$Res> {
  factory _$$QuestionEventUpdateBatchImplCopyWith(
          _$QuestionEventUpdateBatchImpl value,
          $Res Function(_$QuestionEventUpdateBatchImpl) then) =
      __$$QuestionEventUpdateBatchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<UpdateQuestionParams> params});
}

/// @nodoc
class __$$QuestionEventUpdateBatchImplCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res, _$QuestionEventUpdateBatchImpl>
    implements _$$QuestionEventUpdateBatchImplCopyWith<$Res> {
  __$$QuestionEventUpdateBatchImplCopyWithImpl(
      _$QuestionEventUpdateBatchImpl _value,
      $Res Function(_$QuestionEventUpdateBatchImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_$QuestionEventUpdateBatchImpl(
      null == params
          ? _value._params
          : params // ignore: cast_nullable_to_non_nullable
              as List<UpdateQuestionParams>,
    ));
  }
}

/// @nodoc

class _$QuestionEventUpdateBatchImpl implements QuestionEventUpdateBatch {
  const _$QuestionEventUpdateBatchImpl(final List<UpdateQuestionParams> params)
      : _params = params;

  final List<UpdateQuestionParams> _params;
  @override
  List<UpdateQuestionParams> get params {
    if (_params is EqualUnmodifiableListView) return _params;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_params);
  }

  @override
  String toString() {
    return 'QuestionEvent.updateBatch(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionEventUpdateBatchImpl &&
            const DeepCollectionEquality().equals(other._params, _params));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_params));

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionEventUpdateBatchImplCopyWith<_$QuestionEventUpdateBatchImpl>
      get copyWith => __$$QuestionEventUpdateBatchImplCopyWithImpl<
          _$QuestionEventUpdateBatchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllQuestionParams params) getQuestions,
    required TResult Function(String query) filterQuestions,
    required TResult Function(List<CreateQuestionParams> params) createBatch,
    required TResult Function(List<UpdateQuestionParams> params) updateBatch,
    required TResult Function(DeleteQuestionParams params) delete,
  }) {
    return updateBatch(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllQuestionParams params)? getQuestions,
    TResult? Function(String query)? filterQuestions,
    TResult? Function(List<CreateQuestionParams> params)? createBatch,
    TResult? Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult? Function(DeleteQuestionParams params)? delete,
  }) {
    return updateBatch?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllQuestionParams params)? getQuestions,
    TResult Function(String query)? filterQuestions,
    TResult Function(List<CreateQuestionParams> params)? createBatch,
    TResult Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult Function(DeleteQuestionParams params)? delete,
    required TResult orElse(),
  }) {
    if (updateBatch != null) {
      return updateBatch(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionEventClear value) clear,
    required TResult Function(QuestionEventGetQuestions value) getQuestions,
    required TResult Function(QuestionEventFilterQuestions value)
        filterQuestions,
    required TResult Function(QuestionEventCreateBatch value) createBatch,
    required TResult Function(QuestionEventUpdateBatch value) updateBatch,
    required TResult Function(QuestionEventDelete value) delete,
  }) {
    return updateBatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionEventClear value)? clear,
    TResult? Function(QuestionEventGetQuestions value)? getQuestions,
    TResult? Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult? Function(QuestionEventCreateBatch value)? createBatch,
    TResult? Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult? Function(QuestionEventDelete value)? delete,
  }) {
    return updateBatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionEventClear value)? clear,
    TResult Function(QuestionEventGetQuestions value)? getQuestions,
    TResult Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult Function(QuestionEventCreateBatch value)? createBatch,
    TResult Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult Function(QuestionEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (updateBatch != null) {
      return updateBatch(this);
    }
    return orElse();
  }
}

abstract class QuestionEventUpdateBatch implements QuestionEvent {
  const factory QuestionEventUpdateBatch(
      final List<UpdateQuestionParams> params) = _$QuestionEventUpdateBatchImpl;

  List<UpdateQuestionParams> get params;

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionEventUpdateBatchImplCopyWith<_$QuestionEventUpdateBatchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QuestionEventDeleteImplCopyWith<$Res> {
  factory _$$QuestionEventDeleteImplCopyWith(_$QuestionEventDeleteImpl value,
          $Res Function(_$QuestionEventDeleteImpl) then) =
      __$$QuestionEventDeleteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DeleteQuestionParams params});

  $DeleteQuestionParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$QuestionEventDeleteImplCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res, _$QuestionEventDeleteImpl>
    implements _$$QuestionEventDeleteImplCopyWith<$Res> {
  __$$QuestionEventDeleteImplCopyWithImpl(_$QuestionEventDeleteImpl _value,
      $Res Function(_$QuestionEventDeleteImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_$QuestionEventDeleteImpl(
      null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as DeleteQuestionParams,
    ));
  }

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DeleteQuestionParamsCopyWith<$Res> get params {
    return $DeleteQuestionParamsCopyWith<$Res>(_value.params, (value) {
      return _then(_value.copyWith(params: value));
    });
  }
}

/// @nodoc

class _$QuestionEventDeleteImpl implements QuestionEventDelete {
  const _$QuestionEventDeleteImpl(this.params);

  @override
  final DeleteQuestionParams params;

  @override
  String toString() {
    return 'QuestionEvent.delete(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionEventDeleteImpl &&
            (identical(other.params, params) || other.params == params));
  }

  @override
  int get hashCode => Object.hash(runtimeType, params);

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionEventDeleteImplCopyWith<_$QuestionEventDeleteImpl> get copyWith =>
      __$$QuestionEventDeleteImplCopyWithImpl<_$QuestionEventDeleteImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllQuestionParams params) getQuestions,
    required TResult Function(String query) filterQuestions,
    required TResult Function(List<CreateQuestionParams> params) createBatch,
    required TResult Function(List<UpdateQuestionParams> params) updateBatch,
    required TResult Function(DeleteQuestionParams params) delete,
  }) {
    return delete(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllQuestionParams params)? getQuestions,
    TResult? Function(String query)? filterQuestions,
    TResult? Function(List<CreateQuestionParams> params)? createBatch,
    TResult? Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult? Function(DeleteQuestionParams params)? delete,
  }) {
    return delete?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllQuestionParams params)? getQuestions,
    TResult Function(String query)? filterQuestions,
    TResult Function(List<CreateQuestionParams> params)? createBatch,
    TResult Function(List<UpdateQuestionParams> params)? updateBatch,
    TResult Function(DeleteQuestionParams params)? delete,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionEventClear value) clear,
    required TResult Function(QuestionEventGetQuestions value) getQuestions,
    required TResult Function(QuestionEventFilterQuestions value)
        filterQuestions,
    required TResult Function(QuestionEventCreateBatch value) createBatch,
    required TResult Function(QuestionEventUpdateBatch value) updateBatch,
    required TResult Function(QuestionEventDelete value) delete,
  }) {
    return delete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionEventClear value)? clear,
    TResult? Function(QuestionEventGetQuestions value)? getQuestions,
    TResult? Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult? Function(QuestionEventCreateBatch value)? createBatch,
    TResult? Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult? Function(QuestionEventDelete value)? delete,
  }) {
    return delete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionEventClear value)? clear,
    TResult Function(QuestionEventGetQuestions value)? getQuestions,
    TResult Function(QuestionEventFilterQuestions value)? filterQuestions,
    TResult Function(QuestionEventCreateBatch value)? createBatch,
    TResult Function(QuestionEventUpdateBatch value)? updateBatch,
    TResult Function(QuestionEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(this);
    }
    return orElse();
  }
}

abstract class QuestionEventDelete implements QuestionEvent {
  const factory QuestionEventDelete(final DeleteQuestionParams params) =
      _$QuestionEventDeleteImpl;

  DeleteQuestionParams get params;

  /// Create a copy of QuestionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionEventDeleteImplCopyWith<_$QuestionEventDeleteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$QuestionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<QuestionModel> question) createdBatch,
    required TResult Function(List<QuestionModel> question) updatedBatch,
    required TResult Function(QuestionModel question) deleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<QuestionModel> question)? createdBatch,
    TResult? Function(List<QuestionModel> question)? updatedBatch,
    TResult? Function(QuestionModel question)? deleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<QuestionModel> question)? createdBatch,
    TResult Function(List<QuestionModel> question)? updatedBatch,
    TResult Function(QuestionModel question)? deleted,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionStateInitial value) initial,
    required TResult Function(QuestionStateLoading value) loading,
    required TResult Function(QuestionStateLoaded value) loaded,
    required TResult Function(QuestionStateFailure value) failure,
    required TResult Function(QuestionStateCreatedBatch value) createdBatch,
    required TResult Function(QuestionStateUpdatedBatch value) updatedBatch,
    required TResult Function(QuestionStateDeleted value) deleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionStateInitial value)? initial,
    TResult? Function(QuestionStateLoading value)? loading,
    TResult? Function(QuestionStateLoaded value)? loaded,
    TResult? Function(QuestionStateFailure value)? failure,
    TResult? Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult? Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult? Function(QuestionStateDeleted value)? deleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionStateInitial value)? initial,
    TResult Function(QuestionStateLoading value)? loading,
    TResult Function(QuestionStateLoaded value)? loaded,
    TResult Function(QuestionStateFailure value)? failure,
    TResult Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult Function(QuestionStateDeleted value)? deleted,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionStateCopyWith<$Res> {
  factory $QuestionStateCopyWith(
          QuestionState value, $Res Function(QuestionState) then) =
      _$QuestionStateCopyWithImpl<$Res, QuestionState>;
}

/// @nodoc
class _$QuestionStateCopyWithImpl<$Res, $Val extends QuestionState>
    implements $QuestionStateCopyWith<$Res> {
  _$QuestionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$QuestionStateInitialImplCopyWith<$Res> {
  factory _$$QuestionStateInitialImplCopyWith(_$QuestionStateInitialImpl value,
          $Res Function(_$QuestionStateInitialImpl) then) =
      __$$QuestionStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QuestionStateInitialImplCopyWithImpl<$Res>
    extends _$QuestionStateCopyWithImpl<$Res, _$QuestionStateInitialImpl>
    implements _$$QuestionStateInitialImplCopyWith<$Res> {
  __$$QuestionStateInitialImplCopyWithImpl(_$QuestionStateInitialImpl _value,
      $Res Function(_$QuestionStateInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$QuestionStateInitialImpl implements QuestionStateInitial {
  const _$QuestionStateInitialImpl();

  @override
  String toString() {
    return 'QuestionState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<QuestionModel> question) createdBatch,
    required TResult Function(List<QuestionModel> question) updatedBatch,
    required TResult Function(QuestionModel question) deleted,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<QuestionModel> question)? createdBatch,
    TResult? Function(List<QuestionModel> question)? updatedBatch,
    TResult? Function(QuestionModel question)? deleted,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<QuestionModel> question)? createdBatch,
    TResult Function(List<QuestionModel> question)? updatedBatch,
    TResult Function(QuestionModel question)? deleted,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionStateInitial value) initial,
    required TResult Function(QuestionStateLoading value) loading,
    required TResult Function(QuestionStateLoaded value) loaded,
    required TResult Function(QuestionStateFailure value) failure,
    required TResult Function(QuestionStateCreatedBatch value) createdBatch,
    required TResult Function(QuestionStateUpdatedBatch value) updatedBatch,
    required TResult Function(QuestionStateDeleted value) deleted,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionStateInitial value)? initial,
    TResult? Function(QuestionStateLoading value)? loading,
    TResult? Function(QuestionStateLoaded value)? loaded,
    TResult? Function(QuestionStateFailure value)? failure,
    TResult? Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult? Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult? Function(QuestionStateDeleted value)? deleted,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionStateInitial value)? initial,
    TResult Function(QuestionStateLoading value)? loading,
    TResult Function(QuestionStateLoaded value)? loaded,
    TResult Function(QuestionStateFailure value)? failure,
    TResult Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult Function(QuestionStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class QuestionStateInitial implements QuestionState {
  const factory QuestionStateInitial() = _$QuestionStateInitialImpl;
}

/// @nodoc
abstract class _$$QuestionStateLoadingImplCopyWith<$Res> {
  factory _$$QuestionStateLoadingImplCopyWith(_$QuestionStateLoadingImpl value,
          $Res Function(_$QuestionStateLoadingImpl) then) =
      __$$QuestionStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QuestionStateLoadingImplCopyWithImpl<$Res>
    extends _$QuestionStateCopyWithImpl<$Res, _$QuestionStateLoadingImpl>
    implements _$$QuestionStateLoadingImplCopyWith<$Res> {
  __$$QuestionStateLoadingImplCopyWithImpl(_$QuestionStateLoadingImpl _value,
      $Res Function(_$QuestionStateLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$QuestionStateLoadingImpl implements QuestionStateLoading {
  const _$QuestionStateLoadingImpl();

  @override
  String toString() {
    return 'QuestionState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<QuestionModel> question) createdBatch,
    required TResult Function(List<QuestionModel> question) updatedBatch,
    required TResult Function(QuestionModel question) deleted,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<QuestionModel> question)? createdBatch,
    TResult? Function(List<QuestionModel> question)? updatedBatch,
    TResult? Function(QuestionModel question)? deleted,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<QuestionModel> question)? createdBatch,
    TResult Function(List<QuestionModel> question)? updatedBatch,
    TResult Function(QuestionModel question)? deleted,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionStateInitial value) initial,
    required TResult Function(QuestionStateLoading value) loading,
    required TResult Function(QuestionStateLoaded value) loaded,
    required TResult Function(QuestionStateFailure value) failure,
    required TResult Function(QuestionStateCreatedBatch value) createdBatch,
    required TResult Function(QuestionStateUpdatedBatch value) updatedBatch,
    required TResult Function(QuestionStateDeleted value) deleted,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionStateInitial value)? initial,
    TResult? Function(QuestionStateLoading value)? loading,
    TResult? Function(QuestionStateLoaded value)? loaded,
    TResult? Function(QuestionStateFailure value)? failure,
    TResult? Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult? Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult? Function(QuestionStateDeleted value)? deleted,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionStateInitial value)? initial,
    TResult Function(QuestionStateLoading value)? loading,
    TResult Function(QuestionStateLoaded value)? loaded,
    TResult Function(QuestionStateFailure value)? failure,
    TResult Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult Function(QuestionStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class QuestionStateLoading implements QuestionState {
  const factory QuestionStateLoading() = _$QuestionStateLoadingImpl;
}

/// @nodoc
abstract class _$$QuestionStateLoadedImplCopyWith<$Res> {
  factory _$$QuestionStateLoadedImplCopyWith(_$QuestionStateLoadedImpl value,
          $Res Function(_$QuestionStateLoadedImpl) then) =
      __$$QuestionStateLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<QuestionModel> questions, List<QuestionModel> filteredQuestions});
}

/// @nodoc
class __$$QuestionStateLoadedImplCopyWithImpl<$Res>
    extends _$QuestionStateCopyWithImpl<$Res, _$QuestionStateLoadedImpl>
    implements _$$QuestionStateLoadedImplCopyWith<$Res> {
  __$$QuestionStateLoadedImplCopyWithImpl(_$QuestionStateLoadedImpl _value,
      $Res Function(_$QuestionStateLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? questions = null,
    Object? filteredQuestions = null,
  }) {
    return _then(_$QuestionStateLoadedImpl(
      questions: null == questions
          ? _value._questions
          : questions // ignore: cast_nullable_to_non_nullable
              as List<QuestionModel>,
      filteredQuestions: null == filteredQuestions
          ? _value._filteredQuestions
          : filteredQuestions // ignore: cast_nullable_to_non_nullable
              as List<QuestionModel>,
    ));
  }
}

/// @nodoc

class _$QuestionStateLoadedImpl implements QuestionStateLoaded {
  const _$QuestionStateLoadedImpl(
      {required final List<QuestionModel> questions,
      required final List<QuestionModel> filteredQuestions})
      : _questions = questions,
        _filteredQuestions = filteredQuestions;

  final List<QuestionModel> _questions;
  @override
  List<QuestionModel> get questions {
    if (_questions is EqualUnmodifiableListView) return _questions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_questions);
  }

  final List<QuestionModel> _filteredQuestions;
  @override
  List<QuestionModel> get filteredQuestions {
    if (_filteredQuestions is EqualUnmodifiableListView)
      return _filteredQuestions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filteredQuestions);
  }

  @override
  String toString() {
    return 'QuestionState.loaded(questions: $questions, filteredQuestions: $filteredQuestions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionStateLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._questions, _questions) &&
            const DeepCollectionEquality()
                .equals(other._filteredQuestions, _filteredQuestions));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_questions),
      const DeepCollectionEquality().hash(_filteredQuestions));

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionStateLoadedImplCopyWith<_$QuestionStateLoadedImpl> get copyWith =>
      __$$QuestionStateLoadedImplCopyWithImpl<_$QuestionStateLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<QuestionModel> question) createdBatch,
    required TResult Function(List<QuestionModel> question) updatedBatch,
    required TResult Function(QuestionModel question) deleted,
  }) {
    return loaded(questions, filteredQuestions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<QuestionModel> question)? createdBatch,
    TResult? Function(List<QuestionModel> question)? updatedBatch,
    TResult? Function(QuestionModel question)? deleted,
  }) {
    return loaded?.call(questions, filteredQuestions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<QuestionModel> question)? createdBatch,
    TResult Function(List<QuestionModel> question)? updatedBatch,
    TResult Function(QuestionModel question)? deleted,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(questions, filteredQuestions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionStateInitial value) initial,
    required TResult Function(QuestionStateLoading value) loading,
    required TResult Function(QuestionStateLoaded value) loaded,
    required TResult Function(QuestionStateFailure value) failure,
    required TResult Function(QuestionStateCreatedBatch value) createdBatch,
    required TResult Function(QuestionStateUpdatedBatch value) updatedBatch,
    required TResult Function(QuestionStateDeleted value) deleted,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionStateInitial value)? initial,
    TResult? Function(QuestionStateLoading value)? loading,
    TResult? Function(QuestionStateLoaded value)? loaded,
    TResult? Function(QuestionStateFailure value)? failure,
    TResult? Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult? Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult? Function(QuestionStateDeleted value)? deleted,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionStateInitial value)? initial,
    TResult Function(QuestionStateLoading value)? loading,
    TResult Function(QuestionStateLoaded value)? loaded,
    TResult Function(QuestionStateFailure value)? failure,
    TResult Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult Function(QuestionStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class QuestionStateLoaded implements QuestionState {
  const factory QuestionStateLoaded(
          {required final List<QuestionModel> questions,
          required final List<QuestionModel> filteredQuestions}) =
      _$QuestionStateLoadedImpl;

  List<QuestionModel> get questions;
  List<QuestionModel> get filteredQuestions;

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionStateLoadedImplCopyWith<_$QuestionStateLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QuestionStateFailureImplCopyWith<$Res> {
  factory _$$QuestionStateFailureImplCopyWith(_$QuestionStateFailureImpl value,
          $Res Function(_$QuestionStateFailureImpl) then) =
      __$$QuestionStateFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$QuestionStateFailureImplCopyWithImpl<$Res>
    extends _$QuestionStateCopyWithImpl<$Res, _$QuestionStateFailureImpl>
    implements _$$QuestionStateFailureImplCopyWith<$Res> {
  __$$QuestionStateFailureImplCopyWithImpl(_$QuestionStateFailureImpl _value,
      $Res Function(_$QuestionStateFailureImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$QuestionStateFailureImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$QuestionStateFailureImpl implements QuestionStateFailure {
  const _$QuestionStateFailureImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'QuestionState.failure(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionStateFailureImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionStateFailureImplCopyWith<_$QuestionStateFailureImpl>
      get copyWith =>
          __$$QuestionStateFailureImplCopyWithImpl<_$QuestionStateFailureImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<QuestionModel> question) createdBatch,
    required TResult Function(List<QuestionModel> question) updatedBatch,
    required TResult Function(QuestionModel question) deleted,
  }) {
    return failure(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<QuestionModel> question)? createdBatch,
    TResult? Function(List<QuestionModel> question)? updatedBatch,
    TResult? Function(QuestionModel question)? deleted,
  }) {
    return failure?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<QuestionModel> question)? createdBatch,
    TResult Function(List<QuestionModel> question)? updatedBatch,
    TResult Function(QuestionModel question)? deleted,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionStateInitial value) initial,
    required TResult Function(QuestionStateLoading value) loading,
    required TResult Function(QuestionStateLoaded value) loaded,
    required TResult Function(QuestionStateFailure value) failure,
    required TResult Function(QuestionStateCreatedBatch value) createdBatch,
    required TResult Function(QuestionStateUpdatedBatch value) updatedBatch,
    required TResult Function(QuestionStateDeleted value) deleted,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionStateInitial value)? initial,
    TResult? Function(QuestionStateLoading value)? loading,
    TResult? Function(QuestionStateLoaded value)? loaded,
    TResult? Function(QuestionStateFailure value)? failure,
    TResult? Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult? Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult? Function(QuestionStateDeleted value)? deleted,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionStateInitial value)? initial,
    TResult Function(QuestionStateLoading value)? loading,
    TResult Function(QuestionStateLoaded value)? loaded,
    TResult Function(QuestionStateFailure value)? failure,
    TResult Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult Function(QuestionStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class QuestionStateFailure implements QuestionState {
  const factory QuestionStateFailure(final String message) =
      _$QuestionStateFailureImpl;

  String get message;

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionStateFailureImplCopyWith<_$QuestionStateFailureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QuestionStateCreatedBatchImplCopyWith<$Res> {
  factory _$$QuestionStateCreatedBatchImplCopyWith(
          _$QuestionStateCreatedBatchImpl value,
          $Res Function(_$QuestionStateCreatedBatchImpl) then) =
      __$$QuestionStateCreatedBatchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<QuestionModel> question});
}

/// @nodoc
class __$$QuestionStateCreatedBatchImplCopyWithImpl<$Res>
    extends _$QuestionStateCopyWithImpl<$Res, _$QuestionStateCreatedBatchImpl>
    implements _$$QuestionStateCreatedBatchImplCopyWith<$Res> {
  __$$QuestionStateCreatedBatchImplCopyWithImpl(
      _$QuestionStateCreatedBatchImpl _value,
      $Res Function(_$QuestionStateCreatedBatchImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? question = null,
  }) {
    return _then(_$QuestionStateCreatedBatchImpl(
      null == question
          ? _value._question
          : question // ignore: cast_nullable_to_non_nullable
              as List<QuestionModel>,
    ));
  }
}

/// @nodoc

class _$QuestionStateCreatedBatchImpl implements QuestionStateCreatedBatch {
  const _$QuestionStateCreatedBatchImpl(final List<QuestionModel> question)
      : _question = question;

  final List<QuestionModel> _question;
  @override
  List<QuestionModel> get question {
    if (_question is EqualUnmodifiableListView) return _question;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_question);
  }

  @override
  String toString() {
    return 'QuestionState.createdBatch(question: $question)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionStateCreatedBatchImpl &&
            const DeepCollectionEquality().equals(other._question, _question));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_question));

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionStateCreatedBatchImplCopyWith<_$QuestionStateCreatedBatchImpl>
      get copyWith => __$$QuestionStateCreatedBatchImplCopyWithImpl<
          _$QuestionStateCreatedBatchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<QuestionModel> question) createdBatch,
    required TResult Function(List<QuestionModel> question) updatedBatch,
    required TResult Function(QuestionModel question) deleted,
  }) {
    return createdBatch(question);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<QuestionModel> question)? createdBatch,
    TResult? Function(List<QuestionModel> question)? updatedBatch,
    TResult? Function(QuestionModel question)? deleted,
  }) {
    return createdBatch?.call(question);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<QuestionModel> question)? createdBatch,
    TResult Function(List<QuestionModel> question)? updatedBatch,
    TResult Function(QuestionModel question)? deleted,
    required TResult orElse(),
  }) {
    if (createdBatch != null) {
      return createdBatch(question);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionStateInitial value) initial,
    required TResult Function(QuestionStateLoading value) loading,
    required TResult Function(QuestionStateLoaded value) loaded,
    required TResult Function(QuestionStateFailure value) failure,
    required TResult Function(QuestionStateCreatedBatch value) createdBatch,
    required TResult Function(QuestionStateUpdatedBatch value) updatedBatch,
    required TResult Function(QuestionStateDeleted value) deleted,
  }) {
    return createdBatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionStateInitial value)? initial,
    TResult? Function(QuestionStateLoading value)? loading,
    TResult? Function(QuestionStateLoaded value)? loaded,
    TResult? Function(QuestionStateFailure value)? failure,
    TResult? Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult? Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult? Function(QuestionStateDeleted value)? deleted,
  }) {
    return createdBatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionStateInitial value)? initial,
    TResult Function(QuestionStateLoading value)? loading,
    TResult Function(QuestionStateLoaded value)? loaded,
    TResult Function(QuestionStateFailure value)? failure,
    TResult Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult Function(QuestionStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (createdBatch != null) {
      return createdBatch(this);
    }
    return orElse();
  }
}

abstract class QuestionStateCreatedBatch implements QuestionState {
  const factory QuestionStateCreatedBatch(final List<QuestionModel> question) =
      _$QuestionStateCreatedBatchImpl;

  List<QuestionModel> get question;

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionStateCreatedBatchImplCopyWith<_$QuestionStateCreatedBatchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QuestionStateUpdatedBatchImplCopyWith<$Res> {
  factory _$$QuestionStateUpdatedBatchImplCopyWith(
          _$QuestionStateUpdatedBatchImpl value,
          $Res Function(_$QuestionStateUpdatedBatchImpl) then) =
      __$$QuestionStateUpdatedBatchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<QuestionModel> question});
}

/// @nodoc
class __$$QuestionStateUpdatedBatchImplCopyWithImpl<$Res>
    extends _$QuestionStateCopyWithImpl<$Res, _$QuestionStateUpdatedBatchImpl>
    implements _$$QuestionStateUpdatedBatchImplCopyWith<$Res> {
  __$$QuestionStateUpdatedBatchImplCopyWithImpl(
      _$QuestionStateUpdatedBatchImpl _value,
      $Res Function(_$QuestionStateUpdatedBatchImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? question = null,
  }) {
    return _then(_$QuestionStateUpdatedBatchImpl(
      null == question
          ? _value._question
          : question // ignore: cast_nullable_to_non_nullable
              as List<QuestionModel>,
    ));
  }
}

/// @nodoc

class _$QuestionStateUpdatedBatchImpl implements QuestionStateUpdatedBatch {
  const _$QuestionStateUpdatedBatchImpl(final List<QuestionModel> question)
      : _question = question;

  final List<QuestionModel> _question;
  @override
  List<QuestionModel> get question {
    if (_question is EqualUnmodifiableListView) return _question;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_question);
  }

  @override
  String toString() {
    return 'QuestionState.updatedBatch(question: $question)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionStateUpdatedBatchImpl &&
            const DeepCollectionEquality().equals(other._question, _question));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_question));

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionStateUpdatedBatchImplCopyWith<_$QuestionStateUpdatedBatchImpl>
      get copyWith => __$$QuestionStateUpdatedBatchImplCopyWithImpl<
          _$QuestionStateUpdatedBatchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<QuestionModel> question) createdBatch,
    required TResult Function(List<QuestionModel> question) updatedBatch,
    required TResult Function(QuestionModel question) deleted,
  }) {
    return updatedBatch(question);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<QuestionModel> question)? createdBatch,
    TResult? Function(List<QuestionModel> question)? updatedBatch,
    TResult? Function(QuestionModel question)? deleted,
  }) {
    return updatedBatch?.call(question);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<QuestionModel> question)? createdBatch,
    TResult Function(List<QuestionModel> question)? updatedBatch,
    TResult Function(QuestionModel question)? deleted,
    required TResult orElse(),
  }) {
    if (updatedBatch != null) {
      return updatedBatch(question);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionStateInitial value) initial,
    required TResult Function(QuestionStateLoading value) loading,
    required TResult Function(QuestionStateLoaded value) loaded,
    required TResult Function(QuestionStateFailure value) failure,
    required TResult Function(QuestionStateCreatedBatch value) createdBatch,
    required TResult Function(QuestionStateUpdatedBatch value) updatedBatch,
    required TResult Function(QuestionStateDeleted value) deleted,
  }) {
    return updatedBatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionStateInitial value)? initial,
    TResult? Function(QuestionStateLoading value)? loading,
    TResult? Function(QuestionStateLoaded value)? loaded,
    TResult? Function(QuestionStateFailure value)? failure,
    TResult? Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult? Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult? Function(QuestionStateDeleted value)? deleted,
  }) {
    return updatedBatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionStateInitial value)? initial,
    TResult Function(QuestionStateLoading value)? loading,
    TResult Function(QuestionStateLoaded value)? loaded,
    TResult Function(QuestionStateFailure value)? failure,
    TResult Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult Function(QuestionStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (updatedBatch != null) {
      return updatedBatch(this);
    }
    return orElse();
  }
}

abstract class QuestionStateUpdatedBatch implements QuestionState {
  const factory QuestionStateUpdatedBatch(final List<QuestionModel> question) =
      _$QuestionStateUpdatedBatchImpl;

  List<QuestionModel> get question;

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionStateUpdatedBatchImplCopyWith<_$QuestionStateUpdatedBatchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QuestionStateDeletedImplCopyWith<$Res> {
  factory _$$QuestionStateDeletedImplCopyWith(_$QuestionStateDeletedImpl value,
          $Res Function(_$QuestionStateDeletedImpl) then) =
      __$$QuestionStateDeletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({QuestionModel question});

  $QuestionModelCopyWith<$Res> get question;
}

/// @nodoc
class __$$QuestionStateDeletedImplCopyWithImpl<$Res>
    extends _$QuestionStateCopyWithImpl<$Res, _$QuestionStateDeletedImpl>
    implements _$$QuestionStateDeletedImplCopyWith<$Res> {
  __$$QuestionStateDeletedImplCopyWithImpl(_$QuestionStateDeletedImpl _value,
      $Res Function(_$QuestionStateDeletedImpl) _then)
      : super(_value, _then);

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? question = null,
  }) {
    return _then(_$QuestionStateDeletedImpl(
      null == question
          ? _value.question
          : question // ignore: cast_nullable_to_non_nullable
              as QuestionModel,
    ));
  }

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $QuestionModelCopyWith<$Res> get question {
    return $QuestionModelCopyWith<$Res>(_value.question, (value) {
      return _then(_value.copyWith(question: value));
    });
  }
}

/// @nodoc

class _$QuestionStateDeletedImpl implements QuestionStateDeleted {
  const _$QuestionStateDeletedImpl(this.question);

  @override
  final QuestionModel question;

  @override
  String toString() {
    return 'QuestionState.deleted(question: $question)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionStateDeletedImpl &&
            (identical(other.question, question) ||
                other.question == question));
  }

  @override
  int get hashCode => Object.hash(runtimeType, question);

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionStateDeletedImplCopyWith<_$QuestionStateDeletedImpl>
      get copyWith =>
          __$$QuestionStateDeletedImplCopyWithImpl<_$QuestionStateDeletedImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<QuestionModel> question) createdBatch,
    required TResult Function(List<QuestionModel> question) updatedBatch,
    required TResult Function(QuestionModel question) deleted,
  }) {
    return deleted(question);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<QuestionModel> question)? createdBatch,
    TResult? Function(List<QuestionModel> question)? updatedBatch,
    TResult? Function(QuestionModel question)? deleted,
  }) {
    return deleted?.call(question);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<QuestionModel> questions,
            List<QuestionModel> filteredQuestions)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<QuestionModel> question)? createdBatch,
    TResult Function(List<QuestionModel> question)? updatedBatch,
    TResult Function(QuestionModel question)? deleted,
    required TResult orElse(),
  }) {
    if (deleted != null) {
      return deleted(question);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QuestionStateInitial value) initial,
    required TResult Function(QuestionStateLoading value) loading,
    required TResult Function(QuestionStateLoaded value) loaded,
    required TResult Function(QuestionStateFailure value) failure,
    required TResult Function(QuestionStateCreatedBatch value) createdBatch,
    required TResult Function(QuestionStateUpdatedBatch value) updatedBatch,
    required TResult Function(QuestionStateDeleted value) deleted,
  }) {
    return deleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QuestionStateInitial value)? initial,
    TResult? Function(QuestionStateLoading value)? loading,
    TResult? Function(QuestionStateLoaded value)? loaded,
    TResult? Function(QuestionStateFailure value)? failure,
    TResult? Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult? Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult? Function(QuestionStateDeleted value)? deleted,
  }) {
    return deleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QuestionStateInitial value)? initial,
    TResult Function(QuestionStateLoading value)? loading,
    TResult Function(QuestionStateLoaded value)? loaded,
    TResult Function(QuestionStateFailure value)? failure,
    TResult Function(QuestionStateCreatedBatch value)? createdBatch,
    TResult Function(QuestionStateUpdatedBatch value)? updatedBatch,
    TResult Function(QuestionStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (deleted != null) {
      return deleted(this);
    }
    return orElse();
  }
}

abstract class QuestionStateDeleted implements QuestionState {
  const factory QuestionStateDeleted(final QuestionModel question) =
      _$QuestionStateDeletedImpl;

  QuestionModel get question;

  /// Create a copy of QuestionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QuestionStateDeletedImplCopyWith<_$QuestionStateDeletedImpl>
      get copyWith => throw _privateConstructorUsedError;
}
