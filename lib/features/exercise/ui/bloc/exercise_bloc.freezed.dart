// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'exercise_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ExerciseEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllExerciseParams params) getExercises,
    required TResult Function(String query) filterExercises,
    required TResult Function(List<CreateExerciseParams> params) createBatch,
    required TResult Function(List<UpdateExerciseParams> params) update,
    required TResult Function(DeleteExerciseParams params) delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllExerciseParams params)? getExercises,
    TResult? Function(String query)? filterExercises,
    TResult? Function(List<CreateExerciseParams> params)? createBatch,
    TResult? Function(List<UpdateExerciseParams> params)? update,
    TResult? Function(DeleteExerciseParams params)? delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllExerciseParams params)? getExercises,
    TResult Function(String query)? filterExercises,
    TResult Function(List<CreateExerciseParams> params)? createBatch,
    TResult Function(List<UpdateExerciseParams> params)? update,
    TResult Function(DeleteExerciseParams params)? delete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseEventClear value) clear,
    required TResult Function(ExerciseEventGetExercises value) getExercises,
    required TResult Function(ExerciseEventFilterExercises value)
        filterExercises,
    required TResult Function(ExerciseEventCreateBatch value) createBatch,
    required TResult Function(ExerciseEventUpdateBatch value) update,
    required TResult Function(ExerciseEventDelete value) delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseEventClear value)? clear,
    TResult? Function(ExerciseEventGetExercises value)? getExercises,
    TResult? Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult? Function(ExerciseEventCreateBatch value)? createBatch,
    TResult? Function(ExerciseEventUpdateBatch value)? update,
    TResult? Function(ExerciseEventDelete value)? delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseEventClear value)? clear,
    TResult Function(ExerciseEventGetExercises value)? getExercises,
    TResult Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult Function(ExerciseEventCreateBatch value)? createBatch,
    TResult Function(ExerciseEventUpdateBatch value)? update,
    TResult Function(ExerciseEventDelete value)? delete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExerciseEventCopyWith<$Res> {
  factory $ExerciseEventCopyWith(
          ExerciseEvent value, $Res Function(ExerciseEvent) then) =
      _$ExerciseEventCopyWithImpl<$Res, ExerciseEvent>;
}

/// @nodoc
class _$ExerciseEventCopyWithImpl<$Res, $Val extends ExerciseEvent>
    implements $ExerciseEventCopyWith<$Res> {
  _$ExerciseEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ExerciseEventClearImplCopyWith<$Res> {
  factory _$$ExerciseEventClearImplCopyWith(_$ExerciseEventClearImpl value,
          $Res Function(_$ExerciseEventClearImpl) then) =
      __$$ExerciseEventClearImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ExerciseEventClearImplCopyWithImpl<$Res>
    extends _$ExerciseEventCopyWithImpl<$Res, _$ExerciseEventClearImpl>
    implements _$$ExerciseEventClearImplCopyWith<$Res> {
  __$$ExerciseEventClearImplCopyWithImpl(_$ExerciseEventClearImpl _value,
      $Res Function(_$ExerciseEventClearImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ExerciseEventClearImpl implements ExerciseEventClear {
  const _$ExerciseEventClearImpl();

  @override
  String toString() {
    return 'ExerciseEvent.clear()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ExerciseEventClearImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllExerciseParams params) getExercises,
    required TResult Function(String query) filterExercises,
    required TResult Function(List<CreateExerciseParams> params) createBatch,
    required TResult Function(List<UpdateExerciseParams> params) update,
    required TResult Function(DeleteExerciseParams params) delete,
  }) {
    return clear();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllExerciseParams params)? getExercises,
    TResult? Function(String query)? filterExercises,
    TResult? Function(List<CreateExerciseParams> params)? createBatch,
    TResult? Function(List<UpdateExerciseParams> params)? update,
    TResult? Function(DeleteExerciseParams params)? delete,
  }) {
    return clear?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllExerciseParams params)? getExercises,
    TResult Function(String query)? filterExercises,
    TResult Function(List<CreateExerciseParams> params)? createBatch,
    TResult Function(List<UpdateExerciseParams> params)? update,
    TResult Function(DeleteExerciseParams params)? delete,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseEventClear value) clear,
    required TResult Function(ExerciseEventGetExercises value) getExercises,
    required TResult Function(ExerciseEventFilterExercises value)
        filterExercises,
    required TResult Function(ExerciseEventCreateBatch value) createBatch,
    required TResult Function(ExerciseEventUpdateBatch value) update,
    required TResult Function(ExerciseEventDelete value) delete,
  }) {
    return clear(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseEventClear value)? clear,
    TResult? Function(ExerciseEventGetExercises value)? getExercises,
    TResult? Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult? Function(ExerciseEventCreateBatch value)? createBatch,
    TResult? Function(ExerciseEventUpdateBatch value)? update,
    TResult? Function(ExerciseEventDelete value)? delete,
  }) {
    return clear?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseEventClear value)? clear,
    TResult Function(ExerciseEventGetExercises value)? getExercises,
    TResult Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult Function(ExerciseEventCreateBatch value)? createBatch,
    TResult Function(ExerciseEventUpdateBatch value)? update,
    TResult Function(ExerciseEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear(this);
    }
    return orElse();
  }
}

abstract class ExerciseEventClear implements ExerciseEvent {
  const factory ExerciseEventClear() = _$ExerciseEventClearImpl;
}

/// @nodoc
abstract class _$$ExerciseEventGetExercisesImplCopyWith<$Res> {
  factory _$$ExerciseEventGetExercisesImplCopyWith(
          _$ExerciseEventGetExercisesImpl value,
          $Res Function(_$ExerciseEventGetExercisesImpl) then) =
      __$$ExerciseEventGetExercisesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({GetAllExerciseParams params});

  $GetAllExerciseParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$ExerciseEventGetExercisesImplCopyWithImpl<$Res>
    extends _$ExerciseEventCopyWithImpl<$Res, _$ExerciseEventGetExercisesImpl>
    implements _$$ExerciseEventGetExercisesImplCopyWith<$Res> {
  __$$ExerciseEventGetExercisesImplCopyWithImpl(
      _$ExerciseEventGetExercisesImpl _value,
      $Res Function(_$ExerciseEventGetExercisesImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_$ExerciseEventGetExercisesImpl(
      null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as GetAllExerciseParams,
    ));
  }

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GetAllExerciseParamsCopyWith<$Res> get params {
    return $GetAllExerciseParamsCopyWith<$Res>(_value.params, (value) {
      return _then(_value.copyWith(params: value));
    });
  }
}

/// @nodoc

class _$ExerciseEventGetExercisesImpl implements ExerciseEventGetExercises {
  const _$ExerciseEventGetExercisesImpl(this.params);

  @override
  final GetAllExerciseParams params;

  @override
  String toString() {
    return 'ExerciseEvent.getExercises(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseEventGetExercisesImpl &&
            (identical(other.params, params) || other.params == params));
  }

  @override
  int get hashCode => Object.hash(runtimeType, params);

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseEventGetExercisesImplCopyWith<_$ExerciseEventGetExercisesImpl>
      get copyWith => __$$ExerciseEventGetExercisesImplCopyWithImpl<
          _$ExerciseEventGetExercisesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllExerciseParams params) getExercises,
    required TResult Function(String query) filterExercises,
    required TResult Function(List<CreateExerciseParams> params) createBatch,
    required TResult Function(List<UpdateExerciseParams> params) update,
    required TResult Function(DeleteExerciseParams params) delete,
  }) {
    return getExercises(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllExerciseParams params)? getExercises,
    TResult? Function(String query)? filterExercises,
    TResult? Function(List<CreateExerciseParams> params)? createBatch,
    TResult? Function(List<UpdateExerciseParams> params)? update,
    TResult? Function(DeleteExerciseParams params)? delete,
  }) {
    return getExercises?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllExerciseParams params)? getExercises,
    TResult Function(String query)? filterExercises,
    TResult Function(List<CreateExerciseParams> params)? createBatch,
    TResult Function(List<UpdateExerciseParams> params)? update,
    TResult Function(DeleteExerciseParams params)? delete,
    required TResult orElse(),
  }) {
    if (getExercises != null) {
      return getExercises(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseEventClear value) clear,
    required TResult Function(ExerciseEventGetExercises value) getExercises,
    required TResult Function(ExerciseEventFilterExercises value)
        filterExercises,
    required TResult Function(ExerciseEventCreateBatch value) createBatch,
    required TResult Function(ExerciseEventUpdateBatch value) update,
    required TResult Function(ExerciseEventDelete value) delete,
  }) {
    return getExercises(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseEventClear value)? clear,
    TResult? Function(ExerciseEventGetExercises value)? getExercises,
    TResult? Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult? Function(ExerciseEventCreateBatch value)? createBatch,
    TResult? Function(ExerciseEventUpdateBatch value)? update,
    TResult? Function(ExerciseEventDelete value)? delete,
  }) {
    return getExercises?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseEventClear value)? clear,
    TResult Function(ExerciseEventGetExercises value)? getExercises,
    TResult Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult Function(ExerciseEventCreateBatch value)? createBatch,
    TResult Function(ExerciseEventUpdateBatch value)? update,
    TResult Function(ExerciseEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (getExercises != null) {
      return getExercises(this);
    }
    return orElse();
  }
}

abstract class ExerciseEventGetExercises implements ExerciseEvent {
  const factory ExerciseEventGetExercises(final GetAllExerciseParams params) =
      _$ExerciseEventGetExercisesImpl;

  GetAllExerciseParams get params;

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseEventGetExercisesImplCopyWith<_$ExerciseEventGetExercisesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExerciseEventFilterExercisesImplCopyWith<$Res> {
  factory _$$ExerciseEventFilterExercisesImplCopyWith(
          _$ExerciseEventFilterExercisesImpl value,
          $Res Function(_$ExerciseEventFilterExercisesImpl) then) =
      __$$ExerciseEventFilterExercisesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String query});
}

/// @nodoc
class __$$ExerciseEventFilterExercisesImplCopyWithImpl<$Res>
    extends _$ExerciseEventCopyWithImpl<$Res,
        _$ExerciseEventFilterExercisesImpl>
    implements _$$ExerciseEventFilterExercisesImplCopyWith<$Res> {
  __$$ExerciseEventFilterExercisesImplCopyWithImpl(
      _$ExerciseEventFilterExercisesImpl _value,
      $Res Function(_$ExerciseEventFilterExercisesImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? query = null,
  }) {
    return _then(_$ExerciseEventFilterExercisesImpl(
      null == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ExerciseEventFilterExercisesImpl
    implements ExerciseEventFilterExercises {
  const _$ExerciseEventFilterExercisesImpl(this.query);

  @override
  final String query;

  @override
  String toString() {
    return 'ExerciseEvent.filterExercises(query: $query)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseEventFilterExercisesImpl &&
            (identical(other.query, query) || other.query == query));
  }

  @override
  int get hashCode => Object.hash(runtimeType, query);

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseEventFilterExercisesImplCopyWith<
          _$ExerciseEventFilterExercisesImpl>
      get copyWith => __$$ExerciseEventFilterExercisesImplCopyWithImpl<
          _$ExerciseEventFilterExercisesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllExerciseParams params) getExercises,
    required TResult Function(String query) filterExercises,
    required TResult Function(List<CreateExerciseParams> params) createBatch,
    required TResult Function(List<UpdateExerciseParams> params) update,
    required TResult Function(DeleteExerciseParams params) delete,
  }) {
    return filterExercises(query);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllExerciseParams params)? getExercises,
    TResult? Function(String query)? filterExercises,
    TResult? Function(List<CreateExerciseParams> params)? createBatch,
    TResult? Function(List<UpdateExerciseParams> params)? update,
    TResult? Function(DeleteExerciseParams params)? delete,
  }) {
    return filterExercises?.call(query);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllExerciseParams params)? getExercises,
    TResult Function(String query)? filterExercises,
    TResult Function(List<CreateExerciseParams> params)? createBatch,
    TResult Function(List<UpdateExerciseParams> params)? update,
    TResult Function(DeleteExerciseParams params)? delete,
    required TResult orElse(),
  }) {
    if (filterExercises != null) {
      return filterExercises(query);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseEventClear value) clear,
    required TResult Function(ExerciseEventGetExercises value) getExercises,
    required TResult Function(ExerciseEventFilterExercises value)
        filterExercises,
    required TResult Function(ExerciseEventCreateBatch value) createBatch,
    required TResult Function(ExerciseEventUpdateBatch value) update,
    required TResult Function(ExerciseEventDelete value) delete,
  }) {
    return filterExercises(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseEventClear value)? clear,
    TResult? Function(ExerciseEventGetExercises value)? getExercises,
    TResult? Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult? Function(ExerciseEventCreateBatch value)? createBatch,
    TResult? Function(ExerciseEventUpdateBatch value)? update,
    TResult? Function(ExerciseEventDelete value)? delete,
  }) {
    return filterExercises?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseEventClear value)? clear,
    TResult Function(ExerciseEventGetExercises value)? getExercises,
    TResult Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult Function(ExerciseEventCreateBatch value)? createBatch,
    TResult Function(ExerciseEventUpdateBatch value)? update,
    TResult Function(ExerciseEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (filterExercises != null) {
      return filterExercises(this);
    }
    return orElse();
  }
}

abstract class ExerciseEventFilterExercises implements ExerciseEvent {
  const factory ExerciseEventFilterExercises(final String query) =
      _$ExerciseEventFilterExercisesImpl;

  String get query;

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseEventFilterExercisesImplCopyWith<
          _$ExerciseEventFilterExercisesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExerciseEventCreateBatchImplCopyWith<$Res> {
  factory _$$ExerciseEventCreateBatchImplCopyWith(
          _$ExerciseEventCreateBatchImpl value,
          $Res Function(_$ExerciseEventCreateBatchImpl) then) =
      __$$ExerciseEventCreateBatchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<CreateExerciseParams> params});
}

/// @nodoc
class __$$ExerciseEventCreateBatchImplCopyWithImpl<$Res>
    extends _$ExerciseEventCopyWithImpl<$Res, _$ExerciseEventCreateBatchImpl>
    implements _$$ExerciseEventCreateBatchImplCopyWith<$Res> {
  __$$ExerciseEventCreateBatchImplCopyWithImpl(
      _$ExerciseEventCreateBatchImpl _value,
      $Res Function(_$ExerciseEventCreateBatchImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_$ExerciseEventCreateBatchImpl(
      null == params
          ? _value._params
          : params // ignore: cast_nullable_to_non_nullable
              as List<CreateExerciseParams>,
    ));
  }
}

/// @nodoc

class _$ExerciseEventCreateBatchImpl implements ExerciseEventCreateBatch {
  const _$ExerciseEventCreateBatchImpl(final List<CreateExerciseParams> params)
      : _params = params;

  final List<CreateExerciseParams> _params;
  @override
  List<CreateExerciseParams> get params {
    if (_params is EqualUnmodifiableListView) return _params;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_params);
  }

  @override
  String toString() {
    return 'ExerciseEvent.createBatch(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseEventCreateBatchImpl &&
            const DeepCollectionEquality().equals(other._params, _params));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_params));

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseEventCreateBatchImplCopyWith<_$ExerciseEventCreateBatchImpl>
      get copyWith => __$$ExerciseEventCreateBatchImplCopyWithImpl<
          _$ExerciseEventCreateBatchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllExerciseParams params) getExercises,
    required TResult Function(String query) filterExercises,
    required TResult Function(List<CreateExerciseParams> params) createBatch,
    required TResult Function(List<UpdateExerciseParams> params) update,
    required TResult Function(DeleteExerciseParams params) delete,
  }) {
    return createBatch(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllExerciseParams params)? getExercises,
    TResult? Function(String query)? filterExercises,
    TResult? Function(List<CreateExerciseParams> params)? createBatch,
    TResult? Function(List<UpdateExerciseParams> params)? update,
    TResult? Function(DeleteExerciseParams params)? delete,
  }) {
    return createBatch?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllExerciseParams params)? getExercises,
    TResult Function(String query)? filterExercises,
    TResult Function(List<CreateExerciseParams> params)? createBatch,
    TResult Function(List<UpdateExerciseParams> params)? update,
    TResult Function(DeleteExerciseParams params)? delete,
    required TResult orElse(),
  }) {
    if (createBatch != null) {
      return createBatch(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseEventClear value) clear,
    required TResult Function(ExerciseEventGetExercises value) getExercises,
    required TResult Function(ExerciseEventFilterExercises value)
        filterExercises,
    required TResult Function(ExerciseEventCreateBatch value) createBatch,
    required TResult Function(ExerciseEventUpdateBatch value) update,
    required TResult Function(ExerciseEventDelete value) delete,
  }) {
    return createBatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseEventClear value)? clear,
    TResult? Function(ExerciseEventGetExercises value)? getExercises,
    TResult? Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult? Function(ExerciseEventCreateBatch value)? createBatch,
    TResult? Function(ExerciseEventUpdateBatch value)? update,
    TResult? Function(ExerciseEventDelete value)? delete,
  }) {
    return createBatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseEventClear value)? clear,
    TResult Function(ExerciseEventGetExercises value)? getExercises,
    TResult Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult Function(ExerciseEventCreateBatch value)? createBatch,
    TResult Function(ExerciseEventUpdateBatch value)? update,
    TResult Function(ExerciseEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (createBatch != null) {
      return createBatch(this);
    }
    return orElse();
  }
}

abstract class ExerciseEventCreateBatch implements ExerciseEvent {
  const factory ExerciseEventCreateBatch(
      final List<CreateExerciseParams> params) = _$ExerciseEventCreateBatchImpl;

  List<CreateExerciseParams> get params;

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseEventCreateBatchImplCopyWith<_$ExerciseEventCreateBatchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExerciseEventUpdateBatchImplCopyWith<$Res> {
  factory _$$ExerciseEventUpdateBatchImplCopyWith(
          _$ExerciseEventUpdateBatchImpl value,
          $Res Function(_$ExerciseEventUpdateBatchImpl) then) =
      __$$ExerciseEventUpdateBatchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<UpdateExerciseParams> params});
}

/// @nodoc
class __$$ExerciseEventUpdateBatchImplCopyWithImpl<$Res>
    extends _$ExerciseEventCopyWithImpl<$Res, _$ExerciseEventUpdateBatchImpl>
    implements _$$ExerciseEventUpdateBatchImplCopyWith<$Res> {
  __$$ExerciseEventUpdateBatchImplCopyWithImpl(
      _$ExerciseEventUpdateBatchImpl _value,
      $Res Function(_$ExerciseEventUpdateBatchImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_$ExerciseEventUpdateBatchImpl(
      null == params
          ? _value._params
          : params // ignore: cast_nullable_to_non_nullable
              as List<UpdateExerciseParams>,
    ));
  }
}

/// @nodoc

class _$ExerciseEventUpdateBatchImpl implements ExerciseEventUpdateBatch {
  const _$ExerciseEventUpdateBatchImpl(final List<UpdateExerciseParams> params)
      : _params = params;

  final List<UpdateExerciseParams> _params;
  @override
  List<UpdateExerciseParams> get params {
    if (_params is EqualUnmodifiableListView) return _params;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_params);
  }

  @override
  String toString() {
    return 'ExerciseEvent.update(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseEventUpdateBatchImpl &&
            const DeepCollectionEquality().equals(other._params, _params));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_params));

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseEventUpdateBatchImplCopyWith<_$ExerciseEventUpdateBatchImpl>
      get copyWith => __$$ExerciseEventUpdateBatchImplCopyWithImpl<
          _$ExerciseEventUpdateBatchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllExerciseParams params) getExercises,
    required TResult Function(String query) filterExercises,
    required TResult Function(List<CreateExerciseParams> params) createBatch,
    required TResult Function(List<UpdateExerciseParams> params) update,
    required TResult Function(DeleteExerciseParams params) delete,
  }) {
    return update(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllExerciseParams params)? getExercises,
    TResult? Function(String query)? filterExercises,
    TResult? Function(List<CreateExerciseParams> params)? createBatch,
    TResult? Function(List<UpdateExerciseParams> params)? update,
    TResult? Function(DeleteExerciseParams params)? delete,
  }) {
    return update?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllExerciseParams params)? getExercises,
    TResult Function(String query)? filterExercises,
    TResult Function(List<CreateExerciseParams> params)? createBatch,
    TResult Function(List<UpdateExerciseParams> params)? update,
    TResult Function(DeleteExerciseParams params)? delete,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseEventClear value) clear,
    required TResult Function(ExerciseEventGetExercises value) getExercises,
    required TResult Function(ExerciseEventFilterExercises value)
        filterExercises,
    required TResult Function(ExerciseEventCreateBatch value) createBatch,
    required TResult Function(ExerciseEventUpdateBatch value) update,
    required TResult Function(ExerciseEventDelete value) delete,
  }) {
    return update(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseEventClear value)? clear,
    TResult? Function(ExerciseEventGetExercises value)? getExercises,
    TResult? Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult? Function(ExerciseEventCreateBatch value)? createBatch,
    TResult? Function(ExerciseEventUpdateBatch value)? update,
    TResult? Function(ExerciseEventDelete value)? delete,
  }) {
    return update?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseEventClear value)? clear,
    TResult Function(ExerciseEventGetExercises value)? getExercises,
    TResult Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult Function(ExerciseEventCreateBatch value)? createBatch,
    TResult Function(ExerciseEventUpdateBatch value)? update,
    TResult Function(ExerciseEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(this);
    }
    return orElse();
  }
}

abstract class ExerciseEventUpdateBatch implements ExerciseEvent {
  const factory ExerciseEventUpdateBatch(
      final List<UpdateExerciseParams> params) = _$ExerciseEventUpdateBatchImpl;

  List<UpdateExerciseParams> get params;

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseEventUpdateBatchImplCopyWith<_$ExerciseEventUpdateBatchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExerciseEventDeleteImplCopyWith<$Res> {
  factory _$$ExerciseEventDeleteImplCopyWith(_$ExerciseEventDeleteImpl value,
          $Res Function(_$ExerciseEventDeleteImpl) then) =
      __$$ExerciseEventDeleteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DeleteExerciseParams params});

  $DeleteExerciseParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$ExerciseEventDeleteImplCopyWithImpl<$Res>
    extends _$ExerciseEventCopyWithImpl<$Res, _$ExerciseEventDeleteImpl>
    implements _$$ExerciseEventDeleteImplCopyWith<$Res> {
  __$$ExerciseEventDeleteImplCopyWithImpl(_$ExerciseEventDeleteImpl _value,
      $Res Function(_$ExerciseEventDeleteImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_$ExerciseEventDeleteImpl(
      null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as DeleteExerciseParams,
    ));
  }

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DeleteExerciseParamsCopyWith<$Res> get params {
    return $DeleteExerciseParamsCopyWith<$Res>(_value.params, (value) {
      return _then(_value.copyWith(params: value));
    });
  }
}

/// @nodoc

class _$ExerciseEventDeleteImpl implements ExerciseEventDelete {
  const _$ExerciseEventDeleteImpl(this.params);

  @override
  final DeleteExerciseParams params;

  @override
  String toString() {
    return 'ExerciseEvent.delete(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseEventDeleteImpl &&
            (identical(other.params, params) || other.params == params));
  }

  @override
  int get hashCode => Object.hash(runtimeType, params);

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseEventDeleteImplCopyWith<_$ExerciseEventDeleteImpl> get copyWith =>
      __$$ExerciseEventDeleteImplCopyWithImpl<_$ExerciseEventDeleteImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(GetAllExerciseParams params) getExercises,
    required TResult Function(String query) filterExercises,
    required TResult Function(List<CreateExerciseParams> params) createBatch,
    required TResult Function(List<UpdateExerciseParams> params) update,
    required TResult Function(DeleteExerciseParams params) delete,
  }) {
    return delete(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(GetAllExerciseParams params)? getExercises,
    TResult? Function(String query)? filterExercises,
    TResult? Function(List<CreateExerciseParams> params)? createBatch,
    TResult? Function(List<UpdateExerciseParams> params)? update,
    TResult? Function(DeleteExerciseParams params)? delete,
  }) {
    return delete?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(GetAllExerciseParams params)? getExercises,
    TResult Function(String query)? filterExercises,
    TResult Function(List<CreateExerciseParams> params)? createBatch,
    TResult Function(List<UpdateExerciseParams> params)? update,
    TResult Function(DeleteExerciseParams params)? delete,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseEventClear value) clear,
    required TResult Function(ExerciseEventGetExercises value) getExercises,
    required TResult Function(ExerciseEventFilterExercises value)
        filterExercises,
    required TResult Function(ExerciseEventCreateBatch value) createBatch,
    required TResult Function(ExerciseEventUpdateBatch value) update,
    required TResult Function(ExerciseEventDelete value) delete,
  }) {
    return delete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseEventClear value)? clear,
    TResult? Function(ExerciseEventGetExercises value)? getExercises,
    TResult? Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult? Function(ExerciseEventCreateBatch value)? createBatch,
    TResult? Function(ExerciseEventUpdateBatch value)? update,
    TResult? Function(ExerciseEventDelete value)? delete,
  }) {
    return delete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseEventClear value)? clear,
    TResult Function(ExerciseEventGetExercises value)? getExercises,
    TResult Function(ExerciseEventFilterExercises value)? filterExercises,
    TResult Function(ExerciseEventCreateBatch value)? createBatch,
    TResult Function(ExerciseEventUpdateBatch value)? update,
    TResult Function(ExerciseEventDelete value)? delete,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(this);
    }
    return orElse();
  }
}

abstract class ExerciseEventDelete implements ExerciseEvent {
  const factory ExerciseEventDelete(final DeleteExerciseParams params) =
      _$ExerciseEventDeleteImpl;

  DeleteExerciseParams get params;

  /// Create a copy of ExerciseEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseEventDeleteImplCopyWith<_$ExerciseEventDeleteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ExerciseState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<ExerciseModel> exercises) createdBatch,
    required TResult Function(List<ExerciseModel> exercises) updatedBatch,
    required TResult Function(ExerciseModel exercise) deleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<ExerciseModel> exercises)? createdBatch,
    TResult? Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult? Function(ExerciseModel exercise)? deleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<ExerciseModel> exercises)? createdBatch,
    TResult Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult Function(ExerciseModel exercise)? deleted,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseStateInitial value) initial,
    required TResult Function(ExerciseStateLoading value) loading,
    required TResult Function(ExerciseStateLoaded value) loaded,
    required TResult Function(ExerciseStateFailure value) failure,
    required TResult Function(ExerciseStateCreatedBatch value) createdBatch,
    required TResult Function(ExerciseStateUpdatedBatch value) updatedBatch,
    required TResult Function(ExerciseStateDeleted value) deleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseStateInitial value)? initial,
    TResult? Function(ExerciseStateLoading value)? loading,
    TResult? Function(ExerciseStateLoaded value)? loaded,
    TResult? Function(ExerciseStateFailure value)? failure,
    TResult? Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult? Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult? Function(ExerciseStateDeleted value)? deleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseStateInitial value)? initial,
    TResult Function(ExerciseStateLoading value)? loading,
    TResult Function(ExerciseStateLoaded value)? loaded,
    TResult Function(ExerciseStateFailure value)? failure,
    TResult Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult Function(ExerciseStateDeleted value)? deleted,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExerciseStateCopyWith<$Res> {
  factory $ExerciseStateCopyWith(
          ExerciseState value, $Res Function(ExerciseState) then) =
      _$ExerciseStateCopyWithImpl<$Res, ExerciseState>;
}

/// @nodoc
class _$ExerciseStateCopyWithImpl<$Res, $Val extends ExerciseState>
    implements $ExerciseStateCopyWith<$Res> {
  _$ExerciseStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ExerciseStateInitialImplCopyWith<$Res> {
  factory _$$ExerciseStateInitialImplCopyWith(_$ExerciseStateInitialImpl value,
          $Res Function(_$ExerciseStateInitialImpl) then) =
      __$$ExerciseStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ExerciseStateInitialImplCopyWithImpl<$Res>
    extends _$ExerciseStateCopyWithImpl<$Res, _$ExerciseStateInitialImpl>
    implements _$$ExerciseStateInitialImplCopyWith<$Res> {
  __$$ExerciseStateInitialImplCopyWithImpl(_$ExerciseStateInitialImpl _value,
      $Res Function(_$ExerciseStateInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ExerciseStateInitialImpl implements ExerciseStateInitial {
  const _$ExerciseStateInitialImpl();

  @override
  String toString() {
    return 'ExerciseState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<ExerciseModel> exercises) createdBatch,
    required TResult Function(List<ExerciseModel> exercises) updatedBatch,
    required TResult Function(ExerciseModel exercise) deleted,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<ExerciseModel> exercises)? createdBatch,
    TResult? Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult? Function(ExerciseModel exercise)? deleted,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<ExerciseModel> exercises)? createdBatch,
    TResult Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult Function(ExerciseModel exercise)? deleted,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseStateInitial value) initial,
    required TResult Function(ExerciseStateLoading value) loading,
    required TResult Function(ExerciseStateLoaded value) loaded,
    required TResult Function(ExerciseStateFailure value) failure,
    required TResult Function(ExerciseStateCreatedBatch value) createdBatch,
    required TResult Function(ExerciseStateUpdatedBatch value) updatedBatch,
    required TResult Function(ExerciseStateDeleted value) deleted,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseStateInitial value)? initial,
    TResult? Function(ExerciseStateLoading value)? loading,
    TResult? Function(ExerciseStateLoaded value)? loaded,
    TResult? Function(ExerciseStateFailure value)? failure,
    TResult? Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult? Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult? Function(ExerciseStateDeleted value)? deleted,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseStateInitial value)? initial,
    TResult Function(ExerciseStateLoading value)? loading,
    TResult Function(ExerciseStateLoaded value)? loaded,
    TResult Function(ExerciseStateFailure value)? failure,
    TResult Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult Function(ExerciseStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ExerciseStateInitial implements ExerciseState {
  const factory ExerciseStateInitial() = _$ExerciseStateInitialImpl;
}

/// @nodoc
abstract class _$$ExerciseStateLoadingImplCopyWith<$Res> {
  factory _$$ExerciseStateLoadingImplCopyWith(_$ExerciseStateLoadingImpl value,
          $Res Function(_$ExerciseStateLoadingImpl) then) =
      __$$ExerciseStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ExerciseStateLoadingImplCopyWithImpl<$Res>
    extends _$ExerciseStateCopyWithImpl<$Res, _$ExerciseStateLoadingImpl>
    implements _$$ExerciseStateLoadingImplCopyWith<$Res> {
  __$$ExerciseStateLoadingImplCopyWithImpl(_$ExerciseStateLoadingImpl _value,
      $Res Function(_$ExerciseStateLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ExerciseStateLoadingImpl implements ExerciseStateLoading {
  const _$ExerciseStateLoadingImpl();

  @override
  String toString() {
    return 'ExerciseState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<ExerciseModel> exercises) createdBatch,
    required TResult Function(List<ExerciseModel> exercises) updatedBatch,
    required TResult Function(ExerciseModel exercise) deleted,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<ExerciseModel> exercises)? createdBatch,
    TResult? Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult? Function(ExerciseModel exercise)? deleted,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<ExerciseModel> exercises)? createdBatch,
    TResult Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult Function(ExerciseModel exercise)? deleted,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseStateInitial value) initial,
    required TResult Function(ExerciseStateLoading value) loading,
    required TResult Function(ExerciseStateLoaded value) loaded,
    required TResult Function(ExerciseStateFailure value) failure,
    required TResult Function(ExerciseStateCreatedBatch value) createdBatch,
    required TResult Function(ExerciseStateUpdatedBatch value) updatedBatch,
    required TResult Function(ExerciseStateDeleted value) deleted,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseStateInitial value)? initial,
    TResult? Function(ExerciseStateLoading value)? loading,
    TResult? Function(ExerciseStateLoaded value)? loaded,
    TResult? Function(ExerciseStateFailure value)? failure,
    TResult? Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult? Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult? Function(ExerciseStateDeleted value)? deleted,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseStateInitial value)? initial,
    TResult Function(ExerciseStateLoading value)? loading,
    TResult Function(ExerciseStateLoaded value)? loaded,
    TResult Function(ExerciseStateFailure value)? failure,
    TResult Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult Function(ExerciseStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ExerciseStateLoading implements ExerciseState {
  const factory ExerciseStateLoading() = _$ExerciseStateLoadingImpl;
}

/// @nodoc
abstract class _$$ExerciseStateLoadedImplCopyWith<$Res> {
  factory _$$ExerciseStateLoadedImplCopyWith(_$ExerciseStateLoadedImpl value,
          $Res Function(_$ExerciseStateLoadedImpl) then) =
      __$$ExerciseStateLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<ExerciseModel> exercises, List<ExerciseModel> filteredExercises});
}

/// @nodoc
class __$$ExerciseStateLoadedImplCopyWithImpl<$Res>
    extends _$ExerciseStateCopyWithImpl<$Res, _$ExerciseStateLoadedImpl>
    implements _$$ExerciseStateLoadedImplCopyWith<$Res> {
  __$$ExerciseStateLoadedImplCopyWithImpl(_$ExerciseStateLoadedImpl _value,
      $Res Function(_$ExerciseStateLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exercises = null,
    Object? filteredExercises = null,
  }) {
    return _then(_$ExerciseStateLoadedImpl(
      exercises: null == exercises
          ? _value._exercises
          : exercises // ignore: cast_nullable_to_non_nullable
              as List<ExerciseModel>,
      filteredExercises: null == filteredExercises
          ? _value._filteredExercises
          : filteredExercises // ignore: cast_nullable_to_non_nullable
              as List<ExerciseModel>,
    ));
  }
}

/// @nodoc

class _$ExerciseStateLoadedImpl implements ExerciseStateLoaded {
  const _$ExerciseStateLoadedImpl(
      {required final List<ExerciseModel> exercises,
      required final List<ExerciseModel> filteredExercises})
      : _exercises = exercises,
        _filteredExercises = filteredExercises;

  final List<ExerciseModel> _exercises;
  @override
  List<ExerciseModel> get exercises {
    if (_exercises is EqualUnmodifiableListView) return _exercises;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_exercises);
  }

  final List<ExerciseModel> _filteredExercises;
  @override
  List<ExerciseModel> get filteredExercises {
    if (_filteredExercises is EqualUnmodifiableListView)
      return _filteredExercises;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filteredExercises);
  }

  @override
  String toString() {
    return 'ExerciseState.loaded(exercises: $exercises, filteredExercises: $filteredExercises)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseStateLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._exercises, _exercises) &&
            const DeepCollectionEquality()
                .equals(other._filteredExercises, _filteredExercises));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_exercises),
      const DeepCollectionEquality().hash(_filteredExercises));

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseStateLoadedImplCopyWith<_$ExerciseStateLoadedImpl> get copyWith =>
      __$$ExerciseStateLoadedImplCopyWithImpl<_$ExerciseStateLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<ExerciseModel> exercises) createdBatch,
    required TResult Function(List<ExerciseModel> exercises) updatedBatch,
    required TResult Function(ExerciseModel exercise) deleted,
  }) {
    return loaded(exercises, filteredExercises);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<ExerciseModel> exercises)? createdBatch,
    TResult? Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult? Function(ExerciseModel exercise)? deleted,
  }) {
    return loaded?.call(exercises, filteredExercises);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<ExerciseModel> exercises)? createdBatch,
    TResult Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult Function(ExerciseModel exercise)? deleted,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(exercises, filteredExercises);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseStateInitial value) initial,
    required TResult Function(ExerciseStateLoading value) loading,
    required TResult Function(ExerciseStateLoaded value) loaded,
    required TResult Function(ExerciseStateFailure value) failure,
    required TResult Function(ExerciseStateCreatedBatch value) createdBatch,
    required TResult Function(ExerciseStateUpdatedBatch value) updatedBatch,
    required TResult Function(ExerciseStateDeleted value) deleted,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseStateInitial value)? initial,
    TResult? Function(ExerciseStateLoading value)? loading,
    TResult? Function(ExerciseStateLoaded value)? loaded,
    TResult? Function(ExerciseStateFailure value)? failure,
    TResult? Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult? Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult? Function(ExerciseStateDeleted value)? deleted,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseStateInitial value)? initial,
    TResult Function(ExerciseStateLoading value)? loading,
    TResult Function(ExerciseStateLoaded value)? loaded,
    TResult Function(ExerciseStateFailure value)? failure,
    TResult Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult Function(ExerciseStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class ExerciseStateLoaded implements ExerciseState {
  const factory ExerciseStateLoaded(
          {required final List<ExerciseModel> exercises,
          required final List<ExerciseModel> filteredExercises}) =
      _$ExerciseStateLoadedImpl;

  List<ExerciseModel> get exercises;
  List<ExerciseModel> get filteredExercises;

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseStateLoadedImplCopyWith<_$ExerciseStateLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExerciseStateFailureImplCopyWith<$Res> {
  factory _$$ExerciseStateFailureImplCopyWith(_$ExerciseStateFailureImpl value,
          $Res Function(_$ExerciseStateFailureImpl) then) =
      __$$ExerciseStateFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ExerciseStateFailureImplCopyWithImpl<$Res>
    extends _$ExerciseStateCopyWithImpl<$Res, _$ExerciseStateFailureImpl>
    implements _$$ExerciseStateFailureImplCopyWith<$Res> {
  __$$ExerciseStateFailureImplCopyWithImpl(_$ExerciseStateFailureImpl _value,
      $Res Function(_$ExerciseStateFailureImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ExerciseStateFailureImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ExerciseStateFailureImpl implements ExerciseStateFailure {
  const _$ExerciseStateFailureImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'ExerciseState.failure(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseStateFailureImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseStateFailureImplCopyWith<_$ExerciseStateFailureImpl>
      get copyWith =>
          __$$ExerciseStateFailureImplCopyWithImpl<_$ExerciseStateFailureImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<ExerciseModel> exercises) createdBatch,
    required TResult Function(List<ExerciseModel> exercises) updatedBatch,
    required TResult Function(ExerciseModel exercise) deleted,
  }) {
    return failure(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<ExerciseModel> exercises)? createdBatch,
    TResult? Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult? Function(ExerciseModel exercise)? deleted,
  }) {
    return failure?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<ExerciseModel> exercises)? createdBatch,
    TResult Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult Function(ExerciseModel exercise)? deleted,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseStateInitial value) initial,
    required TResult Function(ExerciseStateLoading value) loading,
    required TResult Function(ExerciseStateLoaded value) loaded,
    required TResult Function(ExerciseStateFailure value) failure,
    required TResult Function(ExerciseStateCreatedBatch value) createdBatch,
    required TResult Function(ExerciseStateUpdatedBatch value) updatedBatch,
    required TResult Function(ExerciseStateDeleted value) deleted,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseStateInitial value)? initial,
    TResult? Function(ExerciseStateLoading value)? loading,
    TResult? Function(ExerciseStateLoaded value)? loaded,
    TResult? Function(ExerciseStateFailure value)? failure,
    TResult? Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult? Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult? Function(ExerciseStateDeleted value)? deleted,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseStateInitial value)? initial,
    TResult Function(ExerciseStateLoading value)? loading,
    TResult Function(ExerciseStateLoaded value)? loaded,
    TResult Function(ExerciseStateFailure value)? failure,
    TResult Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult Function(ExerciseStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class ExerciseStateFailure implements ExerciseState {
  const factory ExerciseStateFailure(final String message) =
      _$ExerciseStateFailureImpl;

  String get message;

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseStateFailureImplCopyWith<_$ExerciseStateFailureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExerciseStateCreatedBatchImplCopyWith<$Res> {
  factory _$$ExerciseStateCreatedBatchImplCopyWith(
          _$ExerciseStateCreatedBatchImpl value,
          $Res Function(_$ExerciseStateCreatedBatchImpl) then) =
      __$$ExerciseStateCreatedBatchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ExerciseModel> exercises});
}

/// @nodoc
class __$$ExerciseStateCreatedBatchImplCopyWithImpl<$Res>
    extends _$ExerciseStateCopyWithImpl<$Res, _$ExerciseStateCreatedBatchImpl>
    implements _$$ExerciseStateCreatedBatchImplCopyWith<$Res> {
  __$$ExerciseStateCreatedBatchImplCopyWithImpl(
      _$ExerciseStateCreatedBatchImpl _value,
      $Res Function(_$ExerciseStateCreatedBatchImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exercises = null,
  }) {
    return _then(_$ExerciseStateCreatedBatchImpl(
      null == exercises
          ? _value._exercises
          : exercises // ignore: cast_nullable_to_non_nullable
              as List<ExerciseModel>,
    ));
  }
}

/// @nodoc

class _$ExerciseStateCreatedBatchImpl implements ExerciseStateCreatedBatch {
  const _$ExerciseStateCreatedBatchImpl(final List<ExerciseModel> exercises)
      : _exercises = exercises;

  final List<ExerciseModel> _exercises;
  @override
  List<ExerciseModel> get exercises {
    if (_exercises is EqualUnmodifiableListView) return _exercises;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_exercises);
  }

  @override
  String toString() {
    return 'ExerciseState.createdBatch(exercises: $exercises)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseStateCreatedBatchImpl &&
            const DeepCollectionEquality()
                .equals(other._exercises, _exercises));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_exercises));

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseStateCreatedBatchImplCopyWith<_$ExerciseStateCreatedBatchImpl>
      get copyWith => __$$ExerciseStateCreatedBatchImplCopyWithImpl<
          _$ExerciseStateCreatedBatchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<ExerciseModel> exercises) createdBatch,
    required TResult Function(List<ExerciseModel> exercises) updatedBatch,
    required TResult Function(ExerciseModel exercise) deleted,
  }) {
    return createdBatch(exercises);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<ExerciseModel> exercises)? createdBatch,
    TResult? Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult? Function(ExerciseModel exercise)? deleted,
  }) {
    return createdBatch?.call(exercises);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<ExerciseModel> exercises)? createdBatch,
    TResult Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult Function(ExerciseModel exercise)? deleted,
    required TResult orElse(),
  }) {
    if (createdBatch != null) {
      return createdBatch(exercises);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseStateInitial value) initial,
    required TResult Function(ExerciseStateLoading value) loading,
    required TResult Function(ExerciseStateLoaded value) loaded,
    required TResult Function(ExerciseStateFailure value) failure,
    required TResult Function(ExerciseStateCreatedBatch value) createdBatch,
    required TResult Function(ExerciseStateUpdatedBatch value) updatedBatch,
    required TResult Function(ExerciseStateDeleted value) deleted,
  }) {
    return createdBatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseStateInitial value)? initial,
    TResult? Function(ExerciseStateLoading value)? loading,
    TResult? Function(ExerciseStateLoaded value)? loaded,
    TResult? Function(ExerciseStateFailure value)? failure,
    TResult? Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult? Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult? Function(ExerciseStateDeleted value)? deleted,
  }) {
    return createdBatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseStateInitial value)? initial,
    TResult Function(ExerciseStateLoading value)? loading,
    TResult Function(ExerciseStateLoaded value)? loaded,
    TResult Function(ExerciseStateFailure value)? failure,
    TResult Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult Function(ExerciseStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (createdBatch != null) {
      return createdBatch(this);
    }
    return orElse();
  }
}

abstract class ExerciseStateCreatedBatch implements ExerciseState {
  const factory ExerciseStateCreatedBatch(final List<ExerciseModel> exercises) =
      _$ExerciseStateCreatedBatchImpl;

  List<ExerciseModel> get exercises;

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseStateCreatedBatchImplCopyWith<_$ExerciseStateCreatedBatchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExerciseStateUpdatedBatchImplCopyWith<$Res> {
  factory _$$ExerciseStateUpdatedBatchImplCopyWith(
          _$ExerciseStateUpdatedBatchImpl value,
          $Res Function(_$ExerciseStateUpdatedBatchImpl) then) =
      __$$ExerciseStateUpdatedBatchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ExerciseModel> exercises});
}

/// @nodoc
class __$$ExerciseStateUpdatedBatchImplCopyWithImpl<$Res>
    extends _$ExerciseStateCopyWithImpl<$Res, _$ExerciseStateUpdatedBatchImpl>
    implements _$$ExerciseStateUpdatedBatchImplCopyWith<$Res> {
  __$$ExerciseStateUpdatedBatchImplCopyWithImpl(
      _$ExerciseStateUpdatedBatchImpl _value,
      $Res Function(_$ExerciseStateUpdatedBatchImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exercises = null,
  }) {
    return _then(_$ExerciseStateUpdatedBatchImpl(
      null == exercises
          ? _value._exercises
          : exercises // ignore: cast_nullable_to_non_nullable
              as List<ExerciseModel>,
    ));
  }
}

/// @nodoc

class _$ExerciseStateUpdatedBatchImpl implements ExerciseStateUpdatedBatch {
  const _$ExerciseStateUpdatedBatchImpl(final List<ExerciseModel> exercises)
      : _exercises = exercises;

  final List<ExerciseModel> _exercises;
  @override
  List<ExerciseModel> get exercises {
    if (_exercises is EqualUnmodifiableListView) return _exercises;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_exercises);
  }

  @override
  String toString() {
    return 'ExerciseState.updatedBatch(exercises: $exercises)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseStateUpdatedBatchImpl &&
            const DeepCollectionEquality()
                .equals(other._exercises, _exercises));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_exercises));

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseStateUpdatedBatchImplCopyWith<_$ExerciseStateUpdatedBatchImpl>
      get copyWith => __$$ExerciseStateUpdatedBatchImplCopyWithImpl<
          _$ExerciseStateUpdatedBatchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<ExerciseModel> exercises) createdBatch,
    required TResult Function(List<ExerciseModel> exercises) updatedBatch,
    required TResult Function(ExerciseModel exercise) deleted,
  }) {
    return updatedBatch(exercises);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<ExerciseModel> exercises)? createdBatch,
    TResult? Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult? Function(ExerciseModel exercise)? deleted,
  }) {
    return updatedBatch?.call(exercises);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<ExerciseModel> exercises)? createdBatch,
    TResult Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult Function(ExerciseModel exercise)? deleted,
    required TResult orElse(),
  }) {
    if (updatedBatch != null) {
      return updatedBatch(exercises);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseStateInitial value) initial,
    required TResult Function(ExerciseStateLoading value) loading,
    required TResult Function(ExerciseStateLoaded value) loaded,
    required TResult Function(ExerciseStateFailure value) failure,
    required TResult Function(ExerciseStateCreatedBatch value) createdBatch,
    required TResult Function(ExerciseStateUpdatedBatch value) updatedBatch,
    required TResult Function(ExerciseStateDeleted value) deleted,
  }) {
    return updatedBatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseStateInitial value)? initial,
    TResult? Function(ExerciseStateLoading value)? loading,
    TResult? Function(ExerciseStateLoaded value)? loaded,
    TResult? Function(ExerciseStateFailure value)? failure,
    TResult? Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult? Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult? Function(ExerciseStateDeleted value)? deleted,
  }) {
    return updatedBatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseStateInitial value)? initial,
    TResult Function(ExerciseStateLoading value)? loading,
    TResult Function(ExerciseStateLoaded value)? loaded,
    TResult Function(ExerciseStateFailure value)? failure,
    TResult Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult Function(ExerciseStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (updatedBatch != null) {
      return updatedBatch(this);
    }
    return orElse();
  }
}

abstract class ExerciseStateUpdatedBatch implements ExerciseState {
  const factory ExerciseStateUpdatedBatch(final List<ExerciseModel> exercises) =
      _$ExerciseStateUpdatedBatchImpl;

  List<ExerciseModel> get exercises;

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseStateUpdatedBatchImplCopyWith<_$ExerciseStateUpdatedBatchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExerciseStateDeletedImplCopyWith<$Res> {
  factory _$$ExerciseStateDeletedImplCopyWith(_$ExerciseStateDeletedImpl value,
          $Res Function(_$ExerciseStateDeletedImpl) then) =
      __$$ExerciseStateDeletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ExerciseModel exercise});

  $ExerciseModelCopyWith<$Res> get exercise;
}

/// @nodoc
class __$$ExerciseStateDeletedImplCopyWithImpl<$Res>
    extends _$ExerciseStateCopyWithImpl<$Res, _$ExerciseStateDeletedImpl>
    implements _$$ExerciseStateDeletedImplCopyWith<$Res> {
  __$$ExerciseStateDeletedImplCopyWithImpl(_$ExerciseStateDeletedImpl _value,
      $Res Function(_$ExerciseStateDeletedImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exercise = null,
  }) {
    return _then(_$ExerciseStateDeletedImpl(
      null == exercise
          ? _value.exercise
          : exercise // ignore: cast_nullable_to_non_nullable
              as ExerciseModel,
    ));
  }

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ExerciseModelCopyWith<$Res> get exercise {
    return $ExerciseModelCopyWith<$Res>(_value.exercise, (value) {
      return _then(_value.copyWith(exercise: value));
    });
  }
}

/// @nodoc

class _$ExerciseStateDeletedImpl implements ExerciseStateDeleted {
  const _$ExerciseStateDeletedImpl(this.exercise);

  @override
  final ExerciseModel exercise;

  @override
  String toString() {
    return 'ExerciseState.deleted(exercise: $exercise)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseStateDeletedImpl &&
            (identical(other.exercise, exercise) ||
                other.exercise == exercise));
  }

  @override
  int get hashCode => Object.hash(runtimeType, exercise);

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseStateDeletedImplCopyWith<_$ExerciseStateDeletedImpl>
      get copyWith =>
          __$$ExerciseStateDeletedImplCopyWithImpl<_$ExerciseStateDeletedImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)
        loaded,
    required TResult Function(String message) failure,
    required TResult Function(List<ExerciseModel> exercises) createdBatch,
    required TResult Function(List<ExerciseModel> exercises) updatedBatch,
    required TResult Function(ExerciseModel exercise) deleted,
  }) {
    return deleted(exercise);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult? Function(String message)? failure,
    TResult? Function(List<ExerciseModel> exercises)? createdBatch,
    TResult? Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult? Function(ExerciseModel exercise)? deleted,
  }) {
    return deleted?.call(exercise);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<ExerciseModel> exercises,
            List<ExerciseModel> filteredExercises)?
        loaded,
    TResult Function(String message)? failure,
    TResult Function(List<ExerciseModel> exercises)? createdBatch,
    TResult Function(List<ExerciseModel> exercises)? updatedBatch,
    TResult Function(ExerciseModel exercise)? deleted,
    required TResult orElse(),
  }) {
    if (deleted != null) {
      return deleted(exercise);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExerciseStateInitial value) initial,
    required TResult Function(ExerciseStateLoading value) loading,
    required TResult Function(ExerciseStateLoaded value) loaded,
    required TResult Function(ExerciseStateFailure value) failure,
    required TResult Function(ExerciseStateCreatedBatch value) createdBatch,
    required TResult Function(ExerciseStateUpdatedBatch value) updatedBatch,
    required TResult Function(ExerciseStateDeleted value) deleted,
  }) {
    return deleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExerciseStateInitial value)? initial,
    TResult? Function(ExerciseStateLoading value)? loading,
    TResult? Function(ExerciseStateLoaded value)? loaded,
    TResult? Function(ExerciseStateFailure value)? failure,
    TResult? Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult? Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult? Function(ExerciseStateDeleted value)? deleted,
  }) {
    return deleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExerciseStateInitial value)? initial,
    TResult Function(ExerciseStateLoading value)? loading,
    TResult Function(ExerciseStateLoaded value)? loaded,
    TResult Function(ExerciseStateFailure value)? failure,
    TResult Function(ExerciseStateCreatedBatch value)? createdBatch,
    TResult Function(ExerciseStateUpdatedBatch value)? updatedBatch,
    TResult Function(ExerciseStateDeleted value)? deleted,
    required TResult orElse(),
  }) {
    if (deleted != null) {
      return deleted(this);
    }
    return orElse();
  }
}

abstract class ExerciseStateDeleted implements ExerciseState {
  const factory ExerciseStateDeleted(final ExerciseModel exercise) =
      _$ExerciseStateDeletedImpl;

  ExerciseModel get exercise;

  /// Create a copy of ExerciseState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseStateDeletedImplCopyWith<_$ExerciseStateDeletedImpl>
      get copyWith => throw _privateConstructorUsedError;
}
