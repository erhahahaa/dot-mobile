// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bloc_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$BlocEventRead<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(int? id, String? query) get,
    required TResult Function(T item) select,
    required TResult Function(String query) filter,
    required TResult Function(T item) append,
    required TResult Function(int id) remove,
    required TResult Function(dynamic params) getOne,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(int? id, String? query)? get,
    TResult? Function(T item)? select,
    TResult? Function(String query)? filter,
    TResult? Function(T item)? append,
    TResult? Function(int id)? remove,
    TResult? Function(dynamic params)? getOne,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(int? id, String? query)? get,
    TResult Function(T item)? select,
    TResult Function(String query)? filter,
    TResult Function(T item)? append,
    TResult Function(int id)? remove,
    TResult Function(dynamic params)? getOne,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventReadClear<T> value) clear,
    required TResult Function(BlocEventReadGet<T> value) get,
    required TResult Function(BlocEventReadSelect<T> value) select,
    required TResult Function(BlocEventReadFilter<T> value) filter,
    required TResult Function(BlocEventReadAppend<T> value) append,
    required TResult Function(BlocEventReadRemove<T> value) remove,
    required TResult Function(BlocEventReadGetOne<T> value) getOne,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventReadClear<T> value)? clear,
    TResult? Function(BlocEventReadGet<T> value)? get,
    TResult? Function(BlocEventReadSelect<T> value)? select,
    TResult? Function(BlocEventReadFilter<T> value)? filter,
    TResult? Function(BlocEventReadAppend<T> value)? append,
    TResult? Function(BlocEventReadRemove<T> value)? remove,
    TResult? Function(BlocEventReadGetOne<T> value)? getOne,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventReadClear<T> value)? clear,
    TResult Function(BlocEventReadGet<T> value)? get,
    TResult Function(BlocEventReadSelect<T> value)? select,
    TResult Function(BlocEventReadFilter<T> value)? filter,
    TResult Function(BlocEventReadAppend<T> value)? append,
    TResult Function(BlocEventReadRemove<T> value)? remove,
    TResult Function(BlocEventReadGetOne<T> value)? getOne,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlocEventReadCopyWith<T, $Res> {
  factory $BlocEventReadCopyWith(
          BlocEventRead<T> value, $Res Function(BlocEventRead<T>) then) =
      _$BlocEventReadCopyWithImpl<T, $Res, BlocEventRead<T>>;
}

/// @nodoc
class _$BlocEventReadCopyWithImpl<T, $Res, $Val extends BlocEventRead<T>>
    implements $BlocEventReadCopyWith<T, $Res> {
  _$BlocEventReadCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$BlocEventReadClearImplCopyWith<T, $Res> {
  factory _$$BlocEventReadClearImplCopyWith(_$BlocEventReadClearImpl<T> value,
          $Res Function(_$BlocEventReadClearImpl<T>) then) =
      __$$BlocEventReadClearImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$BlocEventReadClearImplCopyWithImpl<T, $Res>
    extends _$BlocEventReadCopyWithImpl<T, $Res, _$BlocEventReadClearImpl<T>>
    implements _$$BlocEventReadClearImplCopyWith<T, $Res> {
  __$$BlocEventReadClearImplCopyWithImpl(_$BlocEventReadClearImpl<T> _value,
      $Res Function(_$BlocEventReadClearImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BlocEventReadClearImpl<T> implements BlocEventReadClear<T> {
  const _$BlocEventReadClearImpl();

  @override
  String toString() {
    return 'BlocEventRead<$T>.clear()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventReadClearImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(int? id, String? query) get,
    required TResult Function(T item) select,
    required TResult Function(String query) filter,
    required TResult Function(T item) append,
    required TResult Function(int id) remove,
    required TResult Function(dynamic params) getOne,
  }) {
    return clear();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(int? id, String? query)? get,
    TResult? Function(T item)? select,
    TResult? Function(String query)? filter,
    TResult? Function(T item)? append,
    TResult? Function(int id)? remove,
    TResult? Function(dynamic params)? getOne,
  }) {
    return clear?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(int? id, String? query)? get,
    TResult Function(T item)? select,
    TResult Function(String query)? filter,
    TResult Function(T item)? append,
    TResult Function(int id)? remove,
    TResult Function(dynamic params)? getOne,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventReadClear<T> value) clear,
    required TResult Function(BlocEventReadGet<T> value) get,
    required TResult Function(BlocEventReadSelect<T> value) select,
    required TResult Function(BlocEventReadFilter<T> value) filter,
    required TResult Function(BlocEventReadAppend<T> value) append,
    required TResult Function(BlocEventReadRemove<T> value) remove,
    required TResult Function(BlocEventReadGetOne<T> value) getOne,
  }) {
    return clear(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventReadClear<T> value)? clear,
    TResult? Function(BlocEventReadGet<T> value)? get,
    TResult? Function(BlocEventReadSelect<T> value)? select,
    TResult? Function(BlocEventReadFilter<T> value)? filter,
    TResult? Function(BlocEventReadAppend<T> value)? append,
    TResult? Function(BlocEventReadRemove<T> value)? remove,
    TResult? Function(BlocEventReadGetOne<T> value)? getOne,
  }) {
    return clear?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventReadClear<T> value)? clear,
    TResult Function(BlocEventReadGet<T> value)? get,
    TResult Function(BlocEventReadSelect<T> value)? select,
    TResult Function(BlocEventReadFilter<T> value)? filter,
    TResult Function(BlocEventReadAppend<T> value)? append,
    TResult Function(BlocEventReadRemove<T> value)? remove,
    TResult Function(BlocEventReadGetOne<T> value)? getOne,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear(this);
    }
    return orElse();
  }
}

abstract class BlocEventReadClear<T> implements BlocEventRead<T> {
  const factory BlocEventReadClear() = _$BlocEventReadClearImpl<T>;
}

/// @nodoc
abstract class _$$BlocEventReadGetImplCopyWith<T, $Res> {
  factory _$$BlocEventReadGetImplCopyWith(_$BlocEventReadGetImpl<T> value,
          $Res Function(_$BlocEventReadGetImpl<T>) then) =
      __$$BlocEventReadGetImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({int? id, String? query});
}

/// @nodoc
class __$$BlocEventReadGetImplCopyWithImpl<T, $Res>
    extends _$BlocEventReadCopyWithImpl<T, $Res, _$BlocEventReadGetImpl<T>>
    implements _$$BlocEventReadGetImplCopyWith<T, $Res> {
  __$$BlocEventReadGetImplCopyWithImpl(_$BlocEventReadGetImpl<T> _value,
      $Res Function(_$BlocEventReadGetImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? query = freezed,
  }) {
    return _then(_$BlocEventReadGetImpl<T>(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      query: freezed == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$BlocEventReadGetImpl<T> implements BlocEventReadGet<T> {
  const _$BlocEventReadGetImpl({this.id, this.query});

  @override
  final int? id;
  @override
  final String? query;

  @override
  String toString() {
    return 'BlocEventRead<$T>.get(id: $id, query: $query)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventReadGetImpl<T> &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.query, query) || other.query == query));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, query);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlocEventReadGetImplCopyWith<T, _$BlocEventReadGetImpl<T>> get copyWith =>
      __$$BlocEventReadGetImplCopyWithImpl<T, _$BlocEventReadGetImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(int? id, String? query) get,
    required TResult Function(T item) select,
    required TResult Function(String query) filter,
    required TResult Function(T item) append,
    required TResult Function(int id) remove,
    required TResult Function(dynamic params) getOne,
  }) {
    return get(id, query);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(int? id, String? query)? get,
    TResult? Function(T item)? select,
    TResult? Function(String query)? filter,
    TResult? Function(T item)? append,
    TResult? Function(int id)? remove,
    TResult? Function(dynamic params)? getOne,
  }) {
    return get?.call(id, query);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(int? id, String? query)? get,
    TResult Function(T item)? select,
    TResult Function(String query)? filter,
    TResult Function(T item)? append,
    TResult Function(int id)? remove,
    TResult Function(dynamic params)? getOne,
    required TResult orElse(),
  }) {
    if (get != null) {
      return get(id, query);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventReadClear<T> value) clear,
    required TResult Function(BlocEventReadGet<T> value) get,
    required TResult Function(BlocEventReadSelect<T> value) select,
    required TResult Function(BlocEventReadFilter<T> value) filter,
    required TResult Function(BlocEventReadAppend<T> value) append,
    required TResult Function(BlocEventReadRemove<T> value) remove,
    required TResult Function(BlocEventReadGetOne<T> value) getOne,
  }) {
    return get(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventReadClear<T> value)? clear,
    TResult? Function(BlocEventReadGet<T> value)? get,
    TResult? Function(BlocEventReadSelect<T> value)? select,
    TResult? Function(BlocEventReadFilter<T> value)? filter,
    TResult? Function(BlocEventReadAppend<T> value)? append,
    TResult? Function(BlocEventReadRemove<T> value)? remove,
    TResult? Function(BlocEventReadGetOne<T> value)? getOne,
  }) {
    return get?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventReadClear<T> value)? clear,
    TResult Function(BlocEventReadGet<T> value)? get,
    TResult Function(BlocEventReadSelect<T> value)? select,
    TResult Function(BlocEventReadFilter<T> value)? filter,
    TResult Function(BlocEventReadAppend<T> value)? append,
    TResult Function(BlocEventReadRemove<T> value)? remove,
    TResult Function(BlocEventReadGetOne<T> value)? getOne,
    required TResult orElse(),
  }) {
    if (get != null) {
      return get(this);
    }
    return orElse();
  }
}

abstract class BlocEventReadGet<T> implements BlocEventRead<T> {
  const factory BlocEventReadGet({final int? id, final String? query}) =
      _$BlocEventReadGetImpl<T>;

  int? get id;
  String? get query;

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlocEventReadGetImplCopyWith<T, _$BlocEventReadGetImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlocEventReadSelectImplCopyWith<T, $Res> {
  factory _$$BlocEventReadSelectImplCopyWith(_$BlocEventReadSelectImpl<T> value,
          $Res Function(_$BlocEventReadSelectImpl<T>) then) =
      __$$BlocEventReadSelectImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T item});
}

/// @nodoc
class __$$BlocEventReadSelectImplCopyWithImpl<T, $Res>
    extends _$BlocEventReadCopyWithImpl<T, $Res, _$BlocEventReadSelectImpl<T>>
    implements _$$BlocEventReadSelectImplCopyWith<T, $Res> {
  __$$BlocEventReadSelectImplCopyWithImpl(_$BlocEventReadSelectImpl<T> _value,
      $Res Function(_$BlocEventReadSelectImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = freezed,
  }) {
    return _then(_$BlocEventReadSelectImpl<T>(
      freezed == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$BlocEventReadSelectImpl<T> implements BlocEventReadSelect<T> {
  const _$BlocEventReadSelectImpl(this.item);

  @override
  final T item;

  @override
  String toString() {
    return 'BlocEventRead<$T>.select(item: $item)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventReadSelectImpl<T> &&
            const DeepCollectionEquality().equals(other.item, item));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(item));

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlocEventReadSelectImplCopyWith<T, _$BlocEventReadSelectImpl<T>>
      get copyWith => __$$BlocEventReadSelectImplCopyWithImpl<T,
          _$BlocEventReadSelectImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(int? id, String? query) get,
    required TResult Function(T item) select,
    required TResult Function(String query) filter,
    required TResult Function(T item) append,
    required TResult Function(int id) remove,
    required TResult Function(dynamic params) getOne,
  }) {
    return select(item);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(int? id, String? query)? get,
    TResult? Function(T item)? select,
    TResult? Function(String query)? filter,
    TResult? Function(T item)? append,
    TResult? Function(int id)? remove,
    TResult? Function(dynamic params)? getOne,
  }) {
    return select?.call(item);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(int? id, String? query)? get,
    TResult Function(T item)? select,
    TResult Function(String query)? filter,
    TResult Function(T item)? append,
    TResult Function(int id)? remove,
    TResult Function(dynamic params)? getOne,
    required TResult orElse(),
  }) {
    if (select != null) {
      return select(item);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventReadClear<T> value) clear,
    required TResult Function(BlocEventReadGet<T> value) get,
    required TResult Function(BlocEventReadSelect<T> value) select,
    required TResult Function(BlocEventReadFilter<T> value) filter,
    required TResult Function(BlocEventReadAppend<T> value) append,
    required TResult Function(BlocEventReadRemove<T> value) remove,
    required TResult Function(BlocEventReadGetOne<T> value) getOne,
  }) {
    return select(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventReadClear<T> value)? clear,
    TResult? Function(BlocEventReadGet<T> value)? get,
    TResult? Function(BlocEventReadSelect<T> value)? select,
    TResult? Function(BlocEventReadFilter<T> value)? filter,
    TResult? Function(BlocEventReadAppend<T> value)? append,
    TResult? Function(BlocEventReadRemove<T> value)? remove,
    TResult? Function(BlocEventReadGetOne<T> value)? getOne,
  }) {
    return select?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventReadClear<T> value)? clear,
    TResult Function(BlocEventReadGet<T> value)? get,
    TResult Function(BlocEventReadSelect<T> value)? select,
    TResult Function(BlocEventReadFilter<T> value)? filter,
    TResult Function(BlocEventReadAppend<T> value)? append,
    TResult Function(BlocEventReadRemove<T> value)? remove,
    TResult Function(BlocEventReadGetOne<T> value)? getOne,
    required TResult orElse(),
  }) {
    if (select != null) {
      return select(this);
    }
    return orElse();
  }
}

abstract class BlocEventReadSelect<T> implements BlocEventRead<T> {
  const factory BlocEventReadSelect(final T item) =
      _$BlocEventReadSelectImpl<T>;

  T get item;

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlocEventReadSelectImplCopyWith<T, _$BlocEventReadSelectImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlocEventReadFilterImplCopyWith<T, $Res> {
  factory _$$BlocEventReadFilterImplCopyWith(_$BlocEventReadFilterImpl<T> value,
          $Res Function(_$BlocEventReadFilterImpl<T>) then) =
      __$$BlocEventReadFilterImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String query});
}

/// @nodoc
class __$$BlocEventReadFilterImplCopyWithImpl<T, $Res>
    extends _$BlocEventReadCopyWithImpl<T, $Res, _$BlocEventReadFilterImpl<T>>
    implements _$$BlocEventReadFilterImplCopyWith<T, $Res> {
  __$$BlocEventReadFilterImplCopyWithImpl(_$BlocEventReadFilterImpl<T> _value,
      $Res Function(_$BlocEventReadFilterImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? query = null,
  }) {
    return _then(_$BlocEventReadFilterImpl<T>(
      null == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BlocEventReadFilterImpl<T> implements BlocEventReadFilter<T> {
  const _$BlocEventReadFilterImpl(this.query);

  @override
  final String query;

  @override
  String toString() {
    return 'BlocEventRead<$T>.filter(query: $query)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventReadFilterImpl<T> &&
            (identical(other.query, query) || other.query == query));
  }

  @override
  int get hashCode => Object.hash(runtimeType, query);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlocEventReadFilterImplCopyWith<T, _$BlocEventReadFilterImpl<T>>
      get copyWith => __$$BlocEventReadFilterImplCopyWithImpl<T,
          _$BlocEventReadFilterImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(int? id, String? query) get,
    required TResult Function(T item) select,
    required TResult Function(String query) filter,
    required TResult Function(T item) append,
    required TResult Function(int id) remove,
    required TResult Function(dynamic params) getOne,
  }) {
    return filter(query);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(int? id, String? query)? get,
    TResult? Function(T item)? select,
    TResult? Function(String query)? filter,
    TResult? Function(T item)? append,
    TResult? Function(int id)? remove,
    TResult? Function(dynamic params)? getOne,
  }) {
    return filter?.call(query);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(int? id, String? query)? get,
    TResult Function(T item)? select,
    TResult Function(String query)? filter,
    TResult Function(T item)? append,
    TResult Function(int id)? remove,
    TResult Function(dynamic params)? getOne,
    required TResult orElse(),
  }) {
    if (filter != null) {
      return filter(query);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventReadClear<T> value) clear,
    required TResult Function(BlocEventReadGet<T> value) get,
    required TResult Function(BlocEventReadSelect<T> value) select,
    required TResult Function(BlocEventReadFilter<T> value) filter,
    required TResult Function(BlocEventReadAppend<T> value) append,
    required TResult Function(BlocEventReadRemove<T> value) remove,
    required TResult Function(BlocEventReadGetOne<T> value) getOne,
  }) {
    return filter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventReadClear<T> value)? clear,
    TResult? Function(BlocEventReadGet<T> value)? get,
    TResult? Function(BlocEventReadSelect<T> value)? select,
    TResult? Function(BlocEventReadFilter<T> value)? filter,
    TResult? Function(BlocEventReadAppend<T> value)? append,
    TResult? Function(BlocEventReadRemove<T> value)? remove,
    TResult? Function(BlocEventReadGetOne<T> value)? getOne,
  }) {
    return filter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventReadClear<T> value)? clear,
    TResult Function(BlocEventReadGet<T> value)? get,
    TResult Function(BlocEventReadSelect<T> value)? select,
    TResult Function(BlocEventReadFilter<T> value)? filter,
    TResult Function(BlocEventReadAppend<T> value)? append,
    TResult Function(BlocEventReadRemove<T> value)? remove,
    TResult Function(BlocEventReadGetOne<T> value)? getOne,
    required TResult orElse(),
  }) {
    if (filter != null) {
      return filter(this);
    }
    return orElse();
  }
}

abstract class BlocEventReadFilter<T> implements BlocEventRead<T> {
  const factory BlocEventReadFilter(final String query) =
      _$BlocEventReadFilterImpl<T>;

  String get query;

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlocEventReadFilterImplCopyWith<T, _$BlocEventReadFilterImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlocEventReadAppendImplCopyWith<T, $Res> {
  factory _$$BlocEventReadAppendImplCopyWith(_$BlocEventReadAppendImpl<T> value,
          $Res Function(_$BlocEventReadAppendImpl<T>) then) =
      __$$BlocEventReadAppendImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T item});
}

/// @nodoc
class __$$BlocEventReadAppendImplCopyWithImpl<T, $Res>
    extends _$BlocEventReadCopyWithImpl<T, $Res, _$BlocEventReadAppendImpl<T>>
    implements _$$BlocEventReadAppendImplCopyWith<T, $Res> {
  __$$BlocEventReadAppendImplCopyWithImpl(_$BlocEventReadAppendImpl<T> _value,
      $Res Function(_$BlocEventReadAppendImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = freezed,
  }) {
    return _then(_$BlocEventReadAppendImpl<T>(
      freezed == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$BlocEventReadAppendImpl<T> implements BlocEventReadAppend<T> {
  const _$BlocEventReadAppendImpl(this.item);

  @override
  final T item;

  @override
  String toString() {
    return 'BlocEventRead<$T>.append(item: $item)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventReadAppendImpl<T> &&
            const DeepCollectionEquality().equals(other.item, item));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(item));

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlocEventReadAppendImplCopyWith<T, _$BlocEventReadAppendImpl<T>>
      get copyWith => __$$BlocEventReadAppendImplCopyWithImpl<T,
          _$BlocEventReadAppendImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(int? id, String? query) get,
    required TResult Function(T item) select,
    required TResult Function(String query) filter,
    required TResult Function(T item) append,
    required TResult Function(int id) remove,
    required TResult Function(dynamic params) getOne,
  }) {
    return append(item);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(int? id, String? query)? get,
    TResult? Function(T item)? select,
    TResult? Function(String query)? filter,
    TResult? Function(T item)? append,
    TResult? Function(int id)? remove,
    TResult? Function(dynamic params)? getOne,
  }) {
    return append?.call(item);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(int? id, String? query)? get,
    TResult Function(T item)? select,
    TResult Function(String query)? filter,
    TResult Function(T item)? append,
    TResult Function(int id)? remove,
    TResult Function(dynamic params)? getOne,
    required TResult orElse(),
  }) {
    if (append != null) {
      return append(item);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventReadClear<T> value) clear,
    required TResult Function(BlocEventReadGet<T> value) get,
    required TResult Function(BlocEventReadSelect<T> value) select,
    required TResult Function(BlocEventReadFilter<T> value) filter,
    required TResult Function(BlocEventReadAppend<T> value) append,
    required TResult Function(BlocEventReadRemove<T> value) remove,
    required TResult Function(BlocEventReadGetOne<T> value) getOne,
  }) {
    return append(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventReadClear<T> value)? clear,
    TResult? Function(BlocEventReadGet<T> value)? get,
    TResult? Function(BlocEventReadSelect<T> value)? select,
    TResult? Function(BlocEventReadFilter<T> value)? filter,
    TResult? Function(BlocEventReadAppend<T> value)? append,
    TResult? Function(BlocEventReadRemove<T> value)? remove,
    TResult? Function(BlocEventReadGetOne<T> value)? getOne,
  }) {
    return append?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventReadClear<T> value)? clear,
    TResult Function(BlocEventReadGet<T> value)? get,
    TResult Function(BlocEventReadSelect<T> value)? select,
    TResult Function(BlocEventReadFilter<T> value)? filter,
    TResult Function(BlocEventReadAppend<T> value)? append,
    TResult Function(BlocEventReadRemove<T> value)? remove,
    TResult Function(BlocEventReadGetOne<T> value)? getOne,
    required TResult orElse(),
  }) {
    if (append != null) {
      return append(this);
    }
    return orElse();
  }
}

abstract class BlocEventReadAppend<T> implements BlocEventRead<T> {
  const factory BlocEventReadAppend(final T item) =
      _$BlocEventReadAppendImpl<T>;

  T get item;

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlocEventReadAppendImplCopyWith<T, _$BlocEventReadAppendImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlocEventReadRemoveImplCopyWith<T, $Res> {
  factory _$$BlocEventReadRemoveImplCopyWith(_$BlocEventReadRemoveImpl<T> value,
          $Res Function(_$BlocEventReadRemoveImpl<T>) then) =
      __$$BlocEventReadRemoveImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({int id});
}

/// @nodoc
class __$$BlocEventReadRemoveImplCopyWithImpl<T, $Res>
    extends _$BlocEventReadCopyWithImpl<T, $Res, _$BlocEventReadRemoveImpl<T>>
    implements _$$BlocEventReadRemoveImplCopyWith<T, $Res> {
  __$$BlocEventReadRemoveImplCopyWithImpl(_$BlocEventReadRemoveImpl<T> _value,
      $Res Function(_$BlocEventReadRemoveImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$BlocEventReadRemoveImpl<T>(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BlocEventReadRemoveImpl<T> implements BlocEventReadRemove<T> {
  const _$BlocEventReadRemoveImpl(this.id);

  @override
  final int id;

  @override
  String toString() {
    return 'BlocEventRead<$T>.remove(id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventReadRemoveImpl<T> &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlocEventReadRemoveImplCopyWith<T, _$BlocEventReadRemoveImpl<T>>
      get copyWith => __$$BlocEventReadRemoveImplCopyWithImpl<T,
          _$BlocEventReadRemoveImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(int? id, String? query) get,
    required TResult Function(T item) select,
    required TResult Function(String query) filter,
    required TResult Function(T item) append,
    required TResult Function(int id) remove,
    required TResult Function(dynamic params) getOne,
  }) {
    return remove(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(int? id, String? query)? get,
    TResult? Function(T item)? select,
    TResult? Function(String query)? filter,
    TResult? Function(T item)? append,
    TResult? Function(int id)? remove,
    TResult? Function(dynamic params)? getOne,
  }) {
    return remove?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(int? id, String? query)? get,
    TResult Function(T item)? select,
    TResult Function(String query)? filter,
    TResult Function(T item)? append,
    TResult Function(int id)? remove,
    TResult Function(dynamic params)? getOne,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventReadClear<T> value) clear,
    required TResult Function(BlocEventReadGet<T> value) get,
    required TResult Function(BlocEventReadSelect<T> value) select,
    required TResult Function(BlocEventReadFilter<T> value) filter,
    required TResult Function(BlocEventReadAppend<T> value) append,
    required TResult Function(BlocEventReadRemove<T> value) remove,
    required TResult Function(BlocEventReadGetOne<T> value) getOne,
  }) {
    return remove(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventReadClear<T> value)? clear,
    TResult? Function(BlocEventReadGet<T> value)? get,
    TResult? Function(BlocEventReadSelect<T> value)? select,
    TResult? Function(BlocEventReadFilter<T> value)? filter,
    TResult? Function(BlocEventReadAppend<T> value)? append,
    TResult? Function(BlocEventReadRemove<T> value)? remove,
    TResult? Function(BlocEventReadGetOne<T> value)? getOne,
  }) {
    return remove?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventReadClear<T> value)? clear,
    TResult Function(BlocEventReadGet<T> value)? get,
    TResult Function(BlocEventReadSelect<T> value)? select,
    TResult Function(BlocEventReadFilter<T> value)? filter,
    TResult Function(BlocEventReadAppend<T> value)? append,
    TResult Function(BlocEventReadRemove<T> value)? remove,
    TResult Function(BlocEventReadGetOne<T> value)? getOne,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(this);
    }
    return orElse();
  }
}

abstract class BlocEventReadRemove<T> implements BlocEventRead<T> {
  const factory BlocEventReadRemove(final int id) =
      _$BlocEventReadRemoveImpl<T>;

  int get id;

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlocEventReadRemoveImplCopyWith<T, _$BlocEventReadRemoveImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlocEventReadGetOneImplCopyWith<T, $Res> {
  factory _$$BlocEventReadGetOneImplCopyWith(_$BlocEventReadGetOneImpl<T> value,
          $Res Function(_$BlocEventReadGetOneImpl<T>) then) =
      __$$BlocEventReadGetOneImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({dynamic params});
}

/// @nodoc
class __$$BlocEventReadGetOneImplCopyWithImpl<T, $Res>
    extends _$BlocEventReadCopyWithImpl<T, $Res, _$BlocEventReadGetOneImpl<T>>
    implements _$$BlocEventReadGetOneImplCopyWith<T, $Res> {
  __$$BlocEventReadGetOneImplCopyWithImpl(_$BlocEventReadGetOneImpl<T> _value,
      $Res Function(_$BlocEventReadGetOneImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = freezed,
  }) {
    return _then(_$BlocEventReadGetOneImpl<T>(
      freezed == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$BlocEventReadGetOneImpl<T> implements BlocEventReadGetOne<T> {
  const _$BlocEventReadGetOneImpl(this.params);

  @override
  final dynamic params;

  @override
  String toString() {
    return 'BlocEventRead<$T>.getOne(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventReadGetOneImpl<T> &&
            const DeepCollectionEquality().equals(other.params, params));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(params));

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlocEventReadGetOneImplCopyWith<T, _$BlocEventReadGetOneImpl<T>>
      get copyWith => __$$BlocEventReadGetOneImplCopyWithImpl<T,
          _$BlocEventReadGetOneImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(int? id, String? query) get,
    required TResult Function(T item) select,
    required TResult Function(String query) filter,
    required TResult Function(T item) append,
    required TResult Function(int id) remove,
    required TResult Function(dynamic params) getOne,
  }) {
    return getOne(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(int? id, String? query)? get,
    TResult? Function(T item)? select,
    TResult? Function(String query)? filter,
    TResult? Function(T item)? append,
    TResult? Function(int id)? remove,
    TResult? Function(dynamic params)? getOne,
  }) {
    return getOne?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(int? id, String? query)? get,
    TResult Function(T item)? select,
    TResult Function(String query)? filter,
    TResult Function(T item)? append,
    TResult Function(int id)? remove,
    TResult Function(dynamic params)? getOne,
    required TResult orElse(),
  }) {
    if (getOne != null) {
      return getOne(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventReadClear<T> value) clear,
    required TResult Function(BlocEventReadGet<T> value) get,
    required TResult Function(BlocEventReadSelect<T> value) select,
    required TResult Function(BlocEventReadFilter<T> value) filter,
    required TResult Function(BlocEventReadAppend<T> value) append,
    required TResult Function(BlocEventReadRemove<T> value) remove,
    required TResult Function(BlocEventReadGetOne<T> value) getOne,
  }) {
    return getOne(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventReadClear<T> value)? clear,
    TResult? Function(BlocEventReadGet<T> value)? get,
    TResult? Function(BlocEventReadSelect<T> value)? select,
    TResult? Function(BlocEventReadFilter<T> value)? filter,
    TResult? Function(BlocEventReadAppend<T> value)? append,
    TResult? Function(BlocEventReadRemove<T> value)? remove,
    TResult? Function(BlocEventReadGetOne<T> value)? getOne,
  }) {
    return getOne?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventReadClear<T> value)? clear,
    TResult Function(BlocEventReadGet<T> value)? get,
    TResult Function(BlocEventReadSelect<T> value)? select,
    TResult Function(BlocEventReadFilter<T> value)? filter,
    TResult Function(BlocEventReadAppend<T> value)? append,
    TResult Function(BlocEventReadRemove<T> value)? remove,
    TResult Function(BlocEventReadGetOne<T> value)? getOne,
    required TResult orElse(),
  }) {
    if (getOne != null) {
      return getOne(this);
    }
    return orElse();
  }
}

abstract class BlocEventReadGetOne<T> implements BlocEventRead<T> {
  const factory BlocEventReadGetOne(final dynamic params) =
      _$BlocEventReadGetOneImpl<T>;

  dynamic get params;

  /// Create a copy of BlocEventRead
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlocEventReadGetOneImplCopyWith<T, _$BlocEventReadGetOneImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BlocEventWrite {
  dynamic get params => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(dynamic params) create,
    required TResult Function(dynamic params) update,
    required TResult Function(dynamic params) delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(dynamic params)? create,
    TResult? Function(dynamic params)? update,
    TResult? Function(dynamic params)? delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(dynamic params)? create,
    TResult Function(dynamic params)? update,
    TResult Function(dynamic params)? delete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventWriteCreate value) create,
    required TResult Function(BlocEventWriteUpdate value) update,
    required TResult Function(BlocEventWriteDelete value) delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventWriteCreate value)? create,
    TResult? Function(BlocEventWriteUpdate value)? update,
    TResult? Function(BlocEventWriteDelete value)? delete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventWriteCreate value)? create,
    TResult Function(BlocEventWriteUpdate value)? update,
    TResult Function(BlocEventWriteDelete value)? delete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BlocEventWriteCopyWith<BlocEventWrite> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlocEventWriteCopyWith<$Res> {
  factory $BlocEventWriteCopyWith(
          BlocEventWrite value, $Res Function(BlocEventWrite) then) =
      _$BlocEventWriteCopyWithImpl<$Res, BlocEventWrite>;
  @useResult
  $Res call({dynamic params});
}

/// @nodoc
class _$BlocEventWriteCopyWithImpl<$Res, $Val extends BlocEventWrite>
    implements $BlocEventWriteCopyWith<$Res> {
  _$BlocEventWriteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = freezed,
  }) {
    return _then(_value.copyWith(
      params: freezed == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BlocEventWriteCreateImplCopyWith<$Res>
    implements $BlocEventWriteCopyWith<$Res> {
  factory _$$BlocEventWriteCreateImplCopyWith(_$BlocEventWriteCreateImpl value,
          $Res Function(_$BlocEventWriteCreateImpl) then) =
      __$$BlocEventWriteCreateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic params});
}

/// @nodoc
class __$$BlocEventWriteCreateImplCopyWithImpl<$Res>
    extends _$BlocEventWriteCopyWithImpl<$Res, _$BlocEventWriteCreateImpl>
    implements _$$BlocEventWriteCreateImplCopyWith<$Res> {
  __$$BlocEventWriteCreateImplCopyWithImpl(_$BlocEventWriteCreateImpl _value,
      $Res Function(_$BlocEventWriteCreateImpl) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = freezed,
  }) {
    return _then(_$BlocEventWriteCreateImpl(
      freezed == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$BlocEventWriteCreateImpl implements BlocEventWriteCreate {
  const _$BlocEventWriteCreateImpl(this.params);

  @override
  final dynamic params;

  @override
  String toString() {
    return 'BlocEventWrite.create(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventWriteCreateImpl &&
            const DeepCollectionEquality().equals(other.params, params));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(params));

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlocEventWriteCreateImplCopyWith<_$BlocEventWriteCreateImpl>
      get copyWith =>
          __$$BlocEventWriteCreateImplCopyWithImpl<_$BlocEventWriteCreateImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(dynamic params) create,
    required TResult Function(dynamic params) update,
    required TResult Function(dynamic params) delete,
  }) {
    return create(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(dynamic params)? create,
    TResult? Function(dynamic params)? update,
    TResult? Function(dynamic params)? delete,
  }) {
    return create?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(dynamic params)? create,
    TResult Function(dynamic params)? update,
    TResult Function(dynamic params)? delete,
    required TResult orElse(),
  }) {
    if (create != null) {
      return create(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventWriteCreate value) create,
    required TResult Function(BlocEventWriteUpdate value) update,
    required TResult Function(BlocEventWriteDelete value) delete,
  }) {
    return create(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventWriteCreate value)? create,
    TResult? Function(BlocEventWriteUpdate value)? update,
    TResult? Function(BlocEventWriteDelete value)? delete,
  }) {
    return create?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventWriteCreate value)? create,
    TResult Function(BlocEventWriteUpdate value)? update,
    TResult Function(BlocEventWriteDelete value)? delete,
    required TResult orElse(),
  }) {
    if (create != null) {
      return create(this);
    }
    return orElse();
  }
}

abstract class BlocEventWriteCreate implements BlocEventWrite {
  const factory BlocEventWriteCreate(final dynamic params) =
      _$BlocEventWriteCreateImpl;

  @override
  dynamic get params;

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlocEventWriteCreateImplCopyWith<_$BlocEventWriteCreateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlocEventWriteUpdateImplCopyWith<$Res>
    implements $BlocEventWriteCopyWith<$Res> {
  factory _$$BlocEventWriteUpdateImplCopyWith(_$BlocEventWriteUpdateImpl value,
          $Res Function(_$BlocEventWriteUpdateImpl) then) =
      __$$BlocEventWriteUpdateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic params});
}

/// @nodoc
class __$$BlocEventWriteUpdateImplCopyWithImpl<$Res>
    extends _$BlocEventWriteCopyWithImpl<$Res, _$BlocEventWriteUpdateImpl>
    implements _$$BlocEventWriteUpdateImplCopyWith<$Res> {
  __$$BlocEventWriteUpdateImplCopyWithImpl(_$BlocEventWriteUpdateImpl _value,
      $Res Function(_$BlocEventWriteUpdateImpl) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = freezed,
  }) {
    return _then(_$BlocEventWriteUpdateImpl(
      freezed == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$BlocEventWriteUpdateImpl implements BlocEventWriteUpdate {
  const _$BlocEventWriteUpdateImpl(this.params);

  @override
  final dynamic params;

  @override
  String toString() {
    return 'BlocEventWrite.update(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventWriteUpdateImpl &&
            const DeepCollectionEquality().equals(other.params, params));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(params));

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlocEventWriteUpdateImplCopyWith<_$BlocEventWriteUpdateImpl>
      get copyWith =>
          __$$BlocEventWriteUpdateImplCopyWithImpl<_$BlocEventWriteUpdateImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(dynamic params) create,
    required TResult Function(dynamic params) update,
    required TResult Function(dynamic params) delete,
  }) {
    return update(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(dynamic params)? create,
    TResult? Function(dynamic params)? update,
    TResult? Function(dynamic params)? delete,
  }) {
    return update?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(dynamic params)? create,
    TResult Function(dynamic params)? update,
    TResult Function(dynamic params)? delete,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventWriteCreate value) create,
    required TResult Function(BlocEventWriteUpdate value) update,
    required TResult Function(BlocEventWriteDelete value) delete,
  }) {
    return update(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventWriteCreate value)? create,
    TResult? Function(BlocEventWriteUpdate value)? update,
    TResult? Function(BlocEventWriteDelete value)? delete,
  }) {
    return update?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventWriteCreate value)? create,
    TResult Function(BlocEventWriteUpdate value)? update,
    TResult Function(BlocEventWriteDelete value)? delete,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(this);
    }
    return orElse();
  }
}

abstract class BlocEventWriteUpdate implements BlocEventWrite {
  const factory BlocEventWriteUpdate(final dynamic params) =
      _$BlocEventWriteUpdateImpl;

  @override
  dynamic get params;

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlocEventWriteUpdateImplCopyWith<_$BlocEventWriteUpdateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlocEventWriteDeleteImplCopyWith<$Res>
    implements $BlocEventWriteCopyWith<$Res> {
  factory _$$BlocEventWriteDeleteImplCopyWith(_$BlocEventWriteDeleteImpl value,
          $Res Function(_$BlocEventWriteDeleteImpl) then) =
      __$$BlocEventWriteDeleteImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic params});
}

/// @nodoc
class __$$BlocEventWriteDeleteImplCopyWithImpl<$Res>
    extends _$BlocEventWriteCopyWithImpl<$Res, _$BlocEventWriteDeleteImpl>
    implements _$$BlocEventWriteDeleteImplCopyWith<$Res> {
  __$$BlocEventWriteDeleteImplCopyWithImpl(_$BlocEventWriteDeleteImpl _value,
      $Res Function(_$BlocEventWriteDeleteImpl) _then)
      : super(_value, _then);

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = freezed,
  }) {
    return _then(_$BlocEventWriteDeleteImpl(
      freezed == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$BlocEventWriteDeleteImpl implements BlocEventWriteDelete {
  const _$BlocEventWriteDeleteImpl(this.params);

  @override
  final dynamic params;

  @override
  String toString() {
    return 'BlocEventWrite.delete(params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlocEventWriteDeleteImpl &&
            const DeepCollectionEquality().equals(other.params, params));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(params));

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlocEventWriteDeleteImplCopyWith<_$BlocEventWriteDeleteImpl>
      get copyWith =>
          __$$BlocEventWriteDeleteImplCopyWithImpl<_$BlocEventWriteDeleteImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(dynamic params) create,
    required TResult Function(dynamic params) update,
    required TResult Function(dynamic params) delete,
  }) {
    return delete(params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(dynamic params)? create,
    TResult? Function(dynamic params)? update,
    TResult? Function(dynamic params)? delete,
  }) {
    return delete?.call(params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(dynamic params)? create,
    TResult Function(dynamic params)? update,
    TResult Function(dynamic params)? delete,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlocEventWriteCreate value) create,
    required TResult Function(BlocEventWriteUpdate value) update,
    required TResult Function(BlocEventWriteDelete value) delete,
  }) {
    return delete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlocEventWriteCreate value)? create,
    TResult? Function(BlocEventWriteUpdate value)? update,
    TResult? Function(BlocEventWriteDelete value)? delete,
  }) {
    return delete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlocEventWriteCreate value)? create,
    TResult Function(BlocEventWriteUpdate value)? update,
    TResult Function(BlocEventWriteDelete value)? delete,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(this);
    }
    return orElse();
  }
}

abstract class BlocEventWriteDelete implements BlocEventWrite {
  const factory BlocEventWriteDelete(final dynamic params) =
      _$BlocEventWriteDeleteImpl;

  @override
  dynamic get params;

  /// Create a copy of BlocEventWrite
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlocEventWriteDeleteImplCopyWith<_$BlocEventWriteDeleteImpl>
      get copyWith => throw _privateConstructorUsedError;
}
